!**************************************************************************************************
!**************************************************************************************************
!**************************************************************************************************
!****                                                                                          ****
!****      This library containes subroutines to generate semilocal momentum-space-regularized ****
!****      chiral NN potentials (sms-chiral) up to N4LO+.                                      ****
!****                                                                                          ****
!****      To generate momentum-space partial-wave matrix elements use the routine:            ****
!****                                                                                          ****
!****      - CHIRALMOMPWD(OSTAT,FORCE,PPUN1,PPUN2,JMOM,CUTNUMQ,POTEN)                          ****
!****        It generates < p',l',s,j | V | p,l,s,j > for given values of the magnitude of the ****
!****        incomung and outgoing momenta p=PPUN2 and p'=PPUN1, [real double precision],      ****
!****        which should be given in GeV, and a fixed value of j=JMOM [integer]. These        ****
!****        parameters should be provided as input. The output vector POTEN(6) [real double   ****
!****        precision] contains MEs for all possible combinations of l, l' and s using the    ****
!****        following notation:                                                               ****
!****          POTEN(1):       s=0, l'=l=j                                                     ****
!****          POTEN(2):       s=1, l'=l=j                                                     ****
!****          POTEN(3):       s=1, l'=l=j-1                                                   ****
!****          POTEN(4):       s=1, l'=j-1, l=j+1                                              ****
!****          POTEN(5):       s=1, l'=j+1, l=j-1                                              ****
!****          POTEN(6):       s=1, l'=l=j+1                                                   ****
!****        Matrix elements POTEN(i) are generated in units of GeV^(-2). Partial-wave MEs     ****
!****        have the standard normalization (CHECK YOUR CONVENTION FOR THE SIGN OF THE        ****
!****        OFF-DIAGONAL MEs) and are to be substituted into the Lippmann-Schwinger equation  ****
!****        without any prefactors, i.e. T = V + integral[k^2 dk V G_0 T].                    ****
!****        NOTICE: this is a DIFFERENT convention compared to the one adopted in the         ****
!****        nonlocal n3lo chiral subroutine "chiral_n3lo.f90" of 2004, where all momenta and  ****
!****        potential MEs were given in units MeV and MeV**(-2) and a different normalization ****
!****        of the LS equation was assumed. In order to bring the PWD MEs of this routine     ****
!****        into the convention of "chiral_n3lo.f90", multiply POTEN(i) by the factor of      ****
!****        PI/2D0/1000000D0.                                                                 ****
!****                                                                                          ****
!****        The remaining input parameters are:                                               ****
!****          OSTAT [integer]:   0,1,2,3,4,5 stays for LO, NLO, N2LO, N3LO, N4LO and N4LO+    ****
!****                             (N4LO+: takes into account the 3F3,1F3,3F3,3F4 contacts)     ****
!****          FORCE [character,len=2]: type of the interaction ('nn', 'pp' or 'np')           ****
!****          CUTNUMQ [integer]: 1, 2, 3, 4 stays for the momentum-space cutoff               ****
!****                             Lambda = 400, 450, 500 and 550 MeV.                          ****
!****                                                                                          ****
!****      Notice:                                                                             ****
!****                                                                                          ****
!****      1. The usage of the new routine is the same as of the "ichiral.f90" one. One only   ****
!****         needs to replace "USE ICHIRAL" by "USE SMSCHIRAL" in the application code.       ****
!****         All conventions are unchanged.                                                   ****
!****                                                                                          ****
!****      2. Due to a local regularization of long-range interactions, the potential          ****
!****         decreases with momenta much slower than the (nonlocal) ones generated by the     ****
!****         old routine "chiral_n3lo.f90". Therefore, integrations over momenta when         ****
!****         solving the Lippmann-Schwinger equation should go up to about 6...7 GeV.         ****
!****                                                                                          ****
!****      3. The potentials at all chiral orders are designed for the standard                ****
!****         non-relativistic-like Lippmann-Schwinger equation with the relativistic          ****
!****         relation between the cms energy and momentum. Also for the deuteron BE one       ****
!****         should use relativistic kinematics.                                              ****
!****                                                                                          ****
!****      4. Always do first initialize the potential for all required momenta and partial    ****
!****         for fixed values of OSTAT and CUTNUMQ. Doing this in a different way will result ****
!****         in a very poor performance of the subroutine.                                    ****
!****                                                                                          ****
!****      5. The potentials for Lambda = 550 MeV are strongly nonperturbative, and one        ****
!****         starts seeing unnaturally large LECs (especially at N3LO). This may affect       ****
!****         reliability of predictions...                                                    ****
!****                                                                                          ****
!****      E.Epelbaum, 18.04.2018                                                              ****
!**************************************************************************************************
!**************************************************************************************************
!**************************************************************************************************
MODULE SMSCHIRAL
IMPLICIT NONE
SAVE
PRIVATE
PUBLIC CHIRALMOMPWD,GetLECNumPPNP,SetLECsPPNP,GetLECsPPNP
INTEGER                    ::NISO,NSPIN
REAL(KIND(0.0D0))          ::PI
PARAMETER                   (PI=3.1415926535897932385D0,&
                             NISO=4,&
                             NSPIN=4)
REAL(KIND(0.0D0))          ::QMAX
PARAMETER                   (QMAX=10D0)

INTEGER                    ::NMU
PARAMETER                   (NMU=128)
REAL(KIND(0.0D0))          ::LAMMU1,LAMMU2,LAMMU3,MUP(0:NMU),MUW(NMU)
PARAMETER                   (LAMMU1=0.2D0,LAMMU2=0.4D0,LAMMU3=2.5D0)
REAL(KIND(0.0D0))          ::ETACQ2(0:NMU),RHOSQ2(0:NMU),&
                             RHOCQ3(0:NMU),ETASQ3(0:NMU),&
                             RHOCQ4(0:NMU),ETACQ4(0:NMU),RHOSQ4(0:NMU),ETASQ4(0:NMU),RHOCQ4REL(0:NMU),ETACQ4REL(0:NMU),&
                             RHOSQ4REL(0:NMU),ETASQ4REL(0:NMU),RHOSLQ4REL(0:NMU),ETASLQ4REL(0:NMU),&
                             RHOCQ5(0:NMU),ETACQ5(0:NMU),RHOSQ5(0:NMU),ETASQ5(0:NMU),RHOCQ5REL(0:NMU),ETACQ5REL(0:NMU),&
                             RHOSQ5REL(0:NMU),ETASQ5REL(0:NMU),RHOSLQ5REL(0:NMU),ETASLQ5REL(0:NMU),&
                             CC20(0:NMU),CC22(0:NMU),CT22(0:NMU),CS20(0:NMU),CS22(0:NMU),CC40(0:NMU),CC42(0:NMU),CC44(0:NMU),&
                             CT42(0:NMU),CT44(0:NMU),CS40(0:NMU),CS42(0:NMU),CS44(0:NMU),CSL22(0:NMU),CSL42(0:NMU),CSL44(0:NMU),&
                             RHOC(0:NMU),RHOS(0:NMU),RHOSL(0:NMU),RHOT(0:NMU),ETAC(0:NMU),ETAS(0:NMU),ETASL(0:NMU),ETAT(0:NMU),&
                             RHOCSUBTR(3,0:NMU),RHOSSUBTR(3,0:NMU),RHOTSUBTR(2,0:NMU),RHOSLSUBTR(2,0:NMU),&
                             ETACSUBTR(3,0:NMU),ETASSUBTR(3,0:NMU),ETATSUBTR(2,0:NMU),ETASLSUBTR(2,0:NMU),&
                             FR(NMU),RESID,&
                             XRHOC(NMU),XRHOS(NMU),XRHOSL(NMU),XRHOT(NMU),XETAC(NMU),XETAS(NMU),XETASL(NMU),XETAT(NMU)

INTEGER                    ::NXP
REAL(KIND(0.0D0))          ::LAMXP1,LAMXP2,LAMXP3
PARAMETER                   (NXP=64,LAMXP1=0.01D0,LAMXP2=0.1D0,LAMXP3=1D0)
REAL(KIND(0.0D0))          ::XP(NXP),XW(NXP)

INTEGER                    ::NCUTQ
PARAMETER                   (NCUTQ=4)
REAL(KIND(0.0D0))          ::CUTQ(NCUTQ),CLO(4,NCUTQ),CNLODR(11,NCUTQ),D1S0OFF,D3S1OFF,DE1OFF,&
                             CN2LODR(11,NCUTQ),CN3LODR(23,NCUTQ),CN4LODR(24,NCUTQ),&
                             CN4LOPLUSDR(24,NCUTQ),CFDR(4,NCUTQ)
REAL(KIND(0.0D0))          ::GA,C1N2LO,C3N2LO,C4N2LO,C1N3LO,C2N3LO,C3N3LO,C4N3LO,&
                             D1PD2N3LO,D3N3LO,D5N3LO,D14MD15N3LO,MPI,MPIN,MPIC,FPI,M,&
                             C1N4LO,C2N4LO,C3N4LO,C4N4LO,D1PD2N4LO,D3N4LO,D5N4LO,D14MD15N4LO,&
                             E14N4LO,E17N4LO,E19N4LO,E21N4LO,E22N4LO,MPROT,MNEUT
PARAMETER                   (GA=1.29D0,&
                             MPI=0.13803D0,MPIN=0.13498D0,MPIC=0.139570D0,FPI=0.0924D0,&
                             MPROT=0.9382720D0,MNEUT=0.9395653D0,&
                             M=2.0D0*MPROT*MNEUT/(MPROT+MNEUT),&
                             C1N2LO=-0.74D0,C3N2LO=-3.61D0,C4N2LO=2.44D0,&
                             C1N3LO=-1.07D0,C2N3LO=3.20D0,C3N3LO=-5.32D0,C4N3LO=3.56D0,&
                             D1PD2N3LO=1.04D0,D3N3LO=-0.48D0,D5N3LO=0.14D0,D14MD15N3LO=-1.90D0,&
                             C1N4LO=-1.10D0,C2N4LO=3.57D0,C3N4LO=-5.54D0,C4N4LO=4.17D0,&
                             D1PD2N4LO=6.18D0,D3N4LO=-8.91D0,D5N4LO=0.86D0,D14MD15N4LO=-12.18D0,&
                             E14N4LO=1.18D0,E17N4LO=-0.18D0,E19N4LO=0D0,E21N4LO=0D0,E22N4LO=0D0,&
                             D1S0OFF=0D0,D3S1OFF=0D0,DE1OFF=0D0,&
                             CUTQ=  (/ 0.40D0, 0.45D0, 0.50D0, 0.55D0 /))
!==================================================================================================
 DATA            CLO    /&                                                                       !=
-0.85634359D-01,-0.10963014D+00,-0.84338518D-01,-0.84934262D-01,&                                !=
-0.75582368D-01,-0.84735749D-01,-0.74671445D-01,-0.75392874D-01,&                                !=
-0.67666109D-01,-0.63981157D-01,-0.67032018D-01,-0.67814779D-01,&                                !=
-0.61282313D-01,-0.45688492D-01,-0.60851133D-01,-0.61657848D-01/                                 !=
 DATA           CNLODR  /&                                                                       !=
-0.92486788D-01, 0.42786538D+00, 0.66659312D+00,-0.12912277D+00, 0.25041525D+00, 0.23439651D+00,&!=
 0.14894753D-01, 0.35324654D+00,-0.40131804D+00,-0.90551119D-01,-0.90118361D-01,&                !=
-0.77938124D-01, 0.49496052D+00, 0.64254690D+00,-0.12511488D+00, 0.36594848D+00, 0.12623390D+00,&!=
 0.11094128D+00, 0.28092810D+00,-0.33914945D+00,-0.76152459D-01,-0.75567406D-01,&                !=
-0.55340770D-01, 0.56248446D+00, 0.65713365D+00,-0.12399479D+00, 0.44452394D+00, 0.40536415D-01,&!=
 0.17476755D+00, 0.22992728D+00,-0.29184670D+00,-0.53533973D-01,-0.52717936D-01,&                !=
-0.88538769D-02, 0.67035253D+00, 0.71382461D+00,-0.12431227D+00, 0.52500202D+00,-0.36937597D-01,&!=
 0.22196439D+00, 0.19540840D+00,-0.25446137D+00,-0.67393914D-02,-0.55425341D-02/                 !=
 DATA           CN2LODR  /&                                                                      !=
-0.39046053D-01, 0.23201083D+00, 0.48807105D+00,-0.71206630D-01, 0.10588720D+00, 0.38628903D+00,&!=
 0.33583927D+00, 0.69673036D+00,-0.17269854D+00,-0.37060239D-01,-0.36544372D-01,&                !=
 0.73531853D-02, 0.19922233D+00, 0.37773895D+00,-0.31018587D-01, 0.18918091D+00, 0.31853848D+00,&!=
 0.53970847D+00, 0.76404881D+00,-0.44238698D-01, 0.91922963D-02, 0.98588308D-02,&                !=
 0.68754509D-01, 0.12493885D+00, 0.29557696D+00, 0.25777129D-01, 0.22244922D+00, 0.28577535D+00,&!=
 0.76387382D+00, 0.90691769D+00, 0.72460123D-01, 0.70584238D-01, 0.71452594D-01,&                !=
 0.14735109D+00, 0.12540839D-01, 0.22966353D+00, 0.11718318D+00, 0.25820687D+00, 0.28527053D+00,&!=
 0.11062293D+01, 0.11789638D+01, 0.18352981D+00, 0.14932449D+00, 0.15046653D+00/                 !=
 DATA           CN3LODR  /&                                                                      !=
-0.12697337D-01,-0.11409842D-01, 0.47058946D+01, 0.77131961D+00, 0.18617223D+01, 0.42324941D+00,&!=
-0.23935634D-01,-0.17108584D+00, 0.51392321D+01, 0.57118043D+00,-0.52466274D+00, 0.19368668D+01,&!=
 0.47685292D+00, 0.17681637D+01, 0.93907370D+00, 0.61060002D+00, 0.11794785D+00,-0.81172304D+00,&!=
-0.35635019D+00,-0.72621067D+00,-0.24162984D+00,-0.10754102D-01,-0.10334359D-01,&                !=
 0.49440168D-01,-0.67850721D-01, 0.35107081D+01, 0.87439710D+00, 0.16426177D-01, 0.95653518D+00,&!=
 0.34615168D-01,-0.17367713D+00, 0.52789104D+01, 0.41432408D+00,-0.23420826D-01, 0.16743525D+01,&!=
 0.82842987D+00, 0.51697927D+00, 0.11390321D+01,-0.24809612D+00, 0.33562743D+00,-0.77188009D+00,&!=
-0.18197136D+00, 0.50421925D+00,-0.89686400D-01, 0.51215345D-01, 0.51770596D-01,&                !=
 0.13301146D+00,-0.20312638D+00, 0.30723347D+01, 0.10015743D+01,-0.82396472D+00, 0.13576260D+01,&!=
 0.11063775D+00,-0.23162065D+00, 0.70243157D+01, 0.32683984D+00, 0.66284743D+00, 0.16958126D+01,&!=
 0.11288804D+01,-0.52859400D+00, 0.13439111D+01,-0.13295721D+01, 0.56815150D+00,-0.90725579D+00,&!=
-0.90879821D-01, 0.12002421D+01, 0.13124469D+00, 0.13470354D+00, 0.13539733D+00,&                !=
 0.23915157D+00,-0.41360905D+00, 0.30279945D+01, 0.11165312D+01,-0.15829452D+01, 0.17291226D+01,&!=
 0.20737220D+00,-0.34424254D+00, 0.22510015D+02, 0.28287914D+00, 0.25257751D+01, 0.18873459D+01,&!=
 0.13769513D+01,-0.15980703D+01, 0.15809080D+01,-0.21637798D+01, 0.81730229D+00,-0.11310195D+01,&!=
-0.46185032D-01, 0.17465524D+01, 0.28419598D+00, 0.24076269D+00, 0.24153388D+00/                 !=
 DATA           CN4LODR  /&                                                                      !=
-0.29766689D-01, 0.64534658D-01, 0.46177431D+01, 0.68753366D+00, 0.15256028D+01,-0.11701621D+00,&!=
-0.37964989D-01,-0.58650136D-01, 0.35485373D+01, 0.53641696D+00,-0.25176048D+00, 0.20049125D+01,&!=
 0.35093571D+00, 0.20792876D+01, 0.77686283D+00, 0.11626373D+01, 0.65378056D-02,-0.67577550D+00,&!=
-0.35780228D+00,-0.86383480D+00,-0.34142521D+00,-0.28511302D-01,-0.28114300D-01, 0.82656960D-01,&!=
 0.10596409D-01, 0.90668141D-01, 0.29620197D+01, 0.75141635D+00,-0.56624456D-01, 0.22509357D+00,&!=
 0.81263935D-02,-0.82384618D-02, 0.28401246D+01, 0.37677818D+00, 0.21050118D-02, 0.13010137D+01,&!=
 0.60504360D+00, 0.10800062D+01, 0.85084393D+00, 0.35125989D+00, 0.12559997D+00,-0.44161702D+00,&!=
-0.16108624D+00, 0.21995219D+00,-0.15825224D+00, 0.11529745D-01, 0.12072447D-01, 0.12626349D+00,&!=
 0.55721428D-01, 0.98355665D-01, 0.20522137D+01, 0.79552088D+00,-0.78025528D+00, 0.37315107D+00,&!=
 0.61057281D-01,-0.88886037D-02, 0.26223804D+01, 0.26914531D+00, 0.19761187D+00, 0.91043526D+00,&!=
 0.78829773D+00, 0.27848711D+00, 0.89013733D+00,-0.25906082D+00, 0.22240887D+00,-0.38226715D+00,&!=
-0.62413083D-01, 0.72934016D+00,-0.26967156D-01, 0.57616928D-01, 0.58307559D-01, 0.13218973D+00,&!=
 0.10201466D+00, 0.10756823D+00, 0.15305529D+01, 0.82393339D+00,-0.11682554D+01, 0.40150259D+00,&!=
 0.11694167D+00,-0.12594036D-01, 0.29664491D+01, 0.19102932D+00, 0.44489122D+00, 0.71116175D+00,&!=
 0.87528802D+00,-0.39990969D+00, 0.87900066D+00,-0.68636262D+00, 0.28646239D+00,-0.37150911D+00,&!=
-0.10230528D-01, 0.99732397D+00, 0.28984615D-01, 0.10525323D+00, 0.10609579D+00, 0.13533421D+00/ !=
 DATA           CN4LOPLUSDR  /&                                                                  !=
-0.31084212D-01, 0.10545698D+00, 0.40436146D+01, 0.69154396D+00, 0.14746530D+01,-0.15284191D+00,&!=
-0.37032422D-01,-0.62658298D-01, 0.35250408D+01, 0.55027068D+00,-0.34473698D+00, 0.21713772D+01,&!=
 0.35006252D+00, 0.18292902D+01, 0.76743540D+00, 0.11103225D+01, 0.85184207D-02,-0.68284150D+00,&!=
-0.42377325D+00,-0.85830150D+00,-0.80887045D-01,-0.28916297D-01,-0.28503677D-01, 0.99192427D-01,&!=
 0.99228428D-02, 0.12088289D+00, 0.25791641D+01, 0.75335003D+00,-0.55362856D-01, 0.21841187D+00,&!=
 0.11362032D-01,-0.24008395D-01, 0.26632201D+01, 0.41014122D+00,-0.32940847D+00, 0.15247226D+01,&!=
 0.59086104D+00, 0.81332739D+00, 0.82779172D+00, 0.21529746D+00, 0.12732081D+00,-0.44857091D+00,&!=
-0.21865023D+00, 0.18630905D+00, 0.13984794D+00, 0.11443091D-01, 0.11992974D-01, 0.13254089D+00,&!=
 0.55814819D-01, 0.11941815D+00, 0.17224586D+01, 0.79369074D+00,-0.73272757D+00, 0.37689523D+00,&!=
 0.66757092D-01,-0.44174456D-01, 0.23436161D+01, 0.31159168D+00,-0.27121798D+00, 0.11395376D+01,&!=
 0.75616572D+00, 0.97157153D-02, 0.85568155D+00,-0.38429124D+00, 0.22376321D+00,-0.38642286D+00,&!=
-0.11846724D+00, 0.67963958D+00, 0.25660340D+00, 0.57611963D-01, 0.58304709D-01, 0.13082766D+00,&!=
 0.10285974D+00, 0.11869347D+00, 0.11821277D+01, 0.81870430D+00,-0.10906382D+01, 0.40964703D+00,&!=
 0.12432527D+00,-0.82969555D-01, 0.24630995D+01, 0.23288696D+00,-0.18364845D+00, 0.90300822D+00,&!=
 0.83343846D+00,-0.62634238D+00, 0.84357392D+00,-0.77155747D+00, 0.28757761D+00,-0.37331655D+00,&!=
-0.67159753D-01, 0.94075553D+00, 0.28195495D+00, 0.10485846D+00, 0.10569869D+00, 0.12356335D+00/ !=
 DATA           CFDR  /&                                                                         !=
 0.24887480D+01, 0.15211077D+01, 0.17698466D+01,-0.22070511D+00,&                                !=
 0.22895546D+01, 0.21609072D+01, 0.13191057D+01, 0.27801873D+00,&                                !=
 0.21377886D+01, 0.23468517D+01, 0.10221168D+01, 0.42816723D+00,&                                !=
 0.20181194D+01, 0.24827607D+01, 0.83566299D+00, 0.42506065D+00/                                 !=
!==================================================================================================
INTEGER                    ::CUTNUMQFIR,OSTATFIR
LOGICAL                    ::FIRST1,FIRST2
DATA                       FIRST1/.FALSE./
DATA                       FIRST2/.FALSE./
INTEGER                    ::NZPUN
PARAMETER                   (NZPUN=64)
REAL(KIND(0.0D0))          ::ZPUN(NZPUN),ZWEI(NZPUN),PL(NZPUN),PLP(NZPUN),PLM(NZPUN)
!***************************************************************************************************
CONTAINS





!***************************************************************************************************
SUBROUTINE CHIRALMOMPWD(OSTAT,FORCE,PPUN1,PPUN2,JMOM,CUTNUMQ,POTEN)
IMPLICIT NONE
INTEGER                    ::I,J,OSTAT,JMOM,CUTNUMQ
REAL(KIND(0.0D0))          ::PPUN1,PPUN2,POTEN(6),POTENOPERATOR(NSPIN,NISO),Q,&
                             V1T(NZPUN),V2T(NZPUN),V3T(NZPUN),V4T(NZPUN),&
                             W1T(NZPUN),W2T(NZPUN),W3T(NZPUN),W4T(NZPUN),&
                             VR1T(6),VR2T(6),VR3T(6),VR4T(6),&
                             WR1T(6),WR2T(6),WR3T(6),WR4T(6),&
                             POTISOT(6),POTISOS(6),POTENCONT(6)
CHARACTER(len=2)           ::FORCE

IF (JMOM .GE. NZPUN/2-5) THEN
  WRITE(*,*)'Increase the number of angular integration points NZPUN'
  STOP
ELSE
  IF (JMOM .LT. 0) THEN
    WRITE(*,*)'Wrong value of JMOM'
    STOP
  END IF
END IF

IF (.NOT. FIRST2) THEN
  CALL GAULEGCH(-1D0,1D0,ZPUN,ZWEI,NZPUN)
  FIRST2=.TRUE.
END IF
DO I=1,NZPUN
  PL(I)=PLFF(ZPUN(I),JMOM)
  PLP(I)=PLFF(ZPUN(I),JMOM+1)
  IF (JMOM .GE. 1) THEN
    PLM(I)=PLFF(ZPUN(I),JMOM-1)
  END IF
END DO

SELECT CASE (FORCE)
CASE ('nn')
  DO I=1,NZPUN
    Q=SQRT(PPUN1**2+PPUN2**2-2D0*PPUN1*PPUN2*ZPUN(I))
    CALL CHIRALMOMLR(OSTAT,Q,CUTNUMQ,POTENOPERATOR)
    IF (OSTAT .GE. 3) THEN
      POTENOPERATOR=POTENOPERATOR*(MNEUT/SQRT(MNEUT**2+PPUN1**2)/2D0+MNEUT/SQRT(MNEUT**2+PPUN2**2)/2D0)
    END IF
    V1T(I)=POTENOPERATOR(1,1)+POTENOPERATOR(1,2)+1D0/4D0*POTENOPERATOR(1,3)-POTENOPERATOR(1,4)
    V2T(I)=POTENOPERATOR(2,1)+POTENOPERATOR(2,2)+1D0/4D0*POTENOPERATOR(2,3)-POTENOPERATOR(2,4)
    V3T(I)=POTENOPERATOR(3,1)+POTENOPERATOR(3,2)+1D0/4D0*POTENOPERATOR(3,3)-POTENOPERATOR(3,4)
    V4T(I)=POTENOPERATOR(4,1)+POTENOPERATOR(4,2)+1D0/4D0*POTENOPERATOR(4,3)-POTENOPERATOR(4,4)
  END DO
  CALL PARCCH(VR1T,V1T,JMOM)
  CALL PARSIGCH(VR2T,V2T,JMOM)
  CALL PARSIGDCH(VR3T,V3T,JMOM,PPUN1,PPUN2)
  CALL PARSLCH(VR4T,V4T,JMOM,PPUN1,PPUN2)
  DO J=1,6
    POTISOT(J)=VR1T(J)+VR2T(J)+VR3T(J)+VR4T(J)
    POTISOS(J)=0D0
  END DO
CASE ('pp')
  DO I=1,NZPUN
    Q=SQRT(PPUN1**2+PPUN2**2-2D0*PPUN1*PPUN2*ZPUN(I))
    CALL CHIRALMOMLR(OSTAT,Q,CUTNUMQ,POTENOPERATOR)
    IF (OSTAT .GE. 3) THEN
      POTENOPERATOR=POTENOPERATOR*(MPROT/SQRT(MPROT**2+PPUN1**2)/2D0+MPROT/SQRT(MPROT**2+PPUN2**2)/2D0)
    END IF
    V1T(I)=POTENOPERATOR(1,1)+POTENOPERATOR(1,2)+1D0/4D0*POTENOPERATOR(1,3)+POTENOPERATOR(1,4)
    V2T(I)=POTENOPERATOR(2,1)+POTENOPERATOR(2,2)+1D0/4D0*POTENOPERATOR(2,3)+POTENOPERATOR(2,4)
    V3T(I)=POTENOPERATOR(3,1)+POTENOPERATOR(3,2)+1D0/4D0*POTENOPERATOR(3,3)+POTENOPERATOR(3,4)
    V4T(I)=POTENOPERATOR(4,1)+POTENOPERATOR(4,2)+1D0/4D0*POTENOPERATOR(4,3)+POTENOPERATOR(4,4)
  END DO
  CALL PARCCH(VR1T,V1T,JMOM)
  CALL PARSIGCH(VR2T,V2T,JMOM)
  CALL PARSIGDCH(VR3T,V3T,JMOM,PPUN1,PPUN2)
  CALL PARSLCH(VR4T,V4T,JMOM,PPUN1,PPUN2)
  DO J=1,6
    POTISOT(J)=VR1T(J)+VR2T(J)+VR3T(J)+VR4T(J)
    POTISOS(J)=0D0
  END DO
CASE ('np')
  DO I=1,NZPUN
    Q=SQRT(PPUN1**2+PPUN2**2-2D0*PPUN1*PPUN2*ZPUN(I))
    CALL CHIRALMOMLR(OSTAT,Q,CUTNUMQ,POTENOPERATOR)
    IF (OSTAT .GE. 3) THEN
      POTENOPERATOR=POTENOPERATOR*(M/SQRT(M**2+PPUN1**2)/2D0+M/SQRT(M**2+PPUN2**2)/2D0)
    END IF
    V1T(I)=POTENOPERATOR(1,1)+POTENOPERATOR(1,2)-1D0/4D0*POTENOPERATOR(1,3)
    V2T(I)=POTENOPERATOR(2,1)+POTENOPERATOR(2,2)-1D0/4D0*POTENOPERATOR(2,3)
    V3T(I)=POTENOPERATOR(3,1)+POTENOPERATOR(3,2)-1D0/4D0*POTENOPERATOR(3,3)
    V4T(I)=POTENOPERATOR(4,1)+POTENOPERATOR(4,2)-1D0/4D0*POTENOPERATOR(4,3)
    W1T(I)=POTENOPERATOR(1,1)-3D0*POTENOPERATOR(1,2)-1D0/4D0*POTENOPERATOR(1,3)
    W2T(I)=POTENOPERATOR(2,1)-3D0*POTENOPERATOR(2,2)-1D0/4D0*POTENOPERATOR(2,3)
    W3T(I)=POTENOPERATOR(3,1)-3D0*POTENOPERATOR(3,2)-1D0/4D0*POTENOPERATOR(3,3)
    W4T(I)=POTENOPERATOR(4,1)-3D0*POTENOPERATOR(4,2)-1D0/4D0*POTENOPERATOR(4,3)
  END DO
  CALL PARCCH(VR1T,V1T,JMOM)
  CALL PARCCH(WR1T,W1T,JMOM)
  CALL PARSIGCH(VR2T,V2T,JMOM)
  CALL PARSIGCH(WR2T,W2T,JMOM)
  CALL PARSIGDCH(VR3T,V3T,JMOM,PPUN1,PPUN2)
  CALL PARSIGDCH(WR3T,W3T,JMOM,PPUN1,PPUN2)
  CALL PARSLCH(VR4T,V4T,JMOM,PPUN1,PPUN2)
  CALL PARSLCH(WR4T,W4T,JMOM,PPUN1,PPUN2)
  DO J=1,6
    POTISOT(J)=VR1T(J)+VR2T(J)+VR3T(J)+VR4T(J)
    POTISOS(J)=WR1T(J)+WR2T(J)+WR3T(J)+WR4T(J)
  END DO
CASE DEFAULT
   WRITE(*,*)'wrong value of FORCE'
   STOP
END SELECT

IF ((JMOM/2)*2 .NE. JMOM) THEN
  POTEN(1)=POTISOS(1)
  POTEN(2)=POTISOT(2)
  POTEN(3)=POTISOS(4)
  POTEN(4)=POTISOS(6)
  POTEN(5)=POTISOS(5)
  POTEN(6)=POTISOS(3)
ELSE
  POTEN(1)=POTISOT(1)
  POTEN(2)=POTISOS(2)
  POTEN(3)=POTISOT(4)
  POTEN(4)=POTISOT(6)
  POTEN(5)=POTISOT(5)
  POTEN(6)=POTISOT(3)
END IF

CALL INITCONTACTS(OSTAT,FORCE,PPUN1,PPUN2,JMOM,CUTNUMQ,POTENCONT)
DO I=1,6
  POTEN(I)=POTEN(I)+POTENCONT(I)
END DO

END SUBROUTINE CHIRALMOMPWD
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE CHIRALMOMLR(OSTAT,QPUN,CUTNUMQ,POTMOM)
IMPLICIT NONE
INTEGER                    ::I,J,OSTAT,CUTNUMQ
REAL(KIND(0.0D0))          ::QPUN,POTMOM(NSPIN,NISO),OPEPMOM(NSPIN,NISO),&
                             TPEPPOLMOM(NSPIN,NISO)

IF (FIRST1) THEN
  IF (OSTAT .NE. OSTATFIR) THEN
    FIRST1=.FALSE.
  END IF
  IF (CUTNUMQ .NE. CUTNUMQFIR) THEN
    FIRST1=.FALSE.
  END IF
END IF

IF (.NOT. FIRST1) THEN
  CALL INFO(OSTAT,CUTNUMQ)
  OSTATFIR=OSTAT
  CUTNUMQFIR=CUTNUMQ
  CALL TRNSCH(NXP/2,NXP/2,NXP,LAMXP1,LAMXP2,LAMXP3,XP,XW)
  CALL INITMU()
  CALL INITSUBTR(CUTNUMQ)
  CALL INITSPECTRAL2PI(OSTAT)
  CALL COMBINESPECTRALFUN(OSTAT,CUTNUMQ)
  FIRST1=.TRUE.
END IF

IF (QPUN .GE. QMAX) THEN
  POTMOM=0D0
  RETURN
END IF

CALL TPEP(QPUN,OSTAT,CUTNUMQ,POTMOM)

CALL OPEP(QPUN,CUTNUMQ,OPEPMOM)
DO I=2,3
   DO J=1,NISO
      POTMOM(I,J)=POTMOM(I,J)+OPEPMOM(I,J)
   END DO
END DO

IF (OSTAT .GE. 3) THEN
   CALL TPEPOLE(QPUN,CUTNUMQ,TPEPPOLMOM)
   POTMOM(1,1)=POTMOM(1,1)+TPEPPOLMOM(1,1)
   POTMOM(1,2)=POTMOM(1,2)+TPEPPOLMOM(1,2)
END IF

END SUBROUTINE CHIRALMOMLR
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE INITSUBTR(CUTNUMQ)
IMPLICIT NONE
INTEGER                    ::I,CUTNUMQ
REAL(KIND(0.0D0))          ::LAMGEV,ERRORF,MU

LAMGEV=CUTQ(CUTNUMQ)*SQRT(2D0)

DO I=0,NMU
  MU=MUP(I)
  ERRORF=ERRORFCOM(MU/LAMGEV)
  CC20(I)=(Mu**2*(LamGev**5 - 4D0*LamGev**3*Mu**2 - 2D0*LamGev*Mu**4 +&
      EXP(Mu**2/LamGev**2)*ErrorF*Mu**3*(5D0*LamGev**2 + 2D0*Mu**2)*Sqrt(Pi)))/LamGev**5
  CC22(I)=(-3D0*LamGev**7 + 4D0*LamGev**3*Mu**4 + 4D0*LamGev*Mu**6 - &
       2D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**5*(3D0*LamGev**2 + 2D0*Mu**2)*Sqrt(Pi))/(3D0*LamGev**7)
  CT22(I)=-(15D0*LamGev**7 - 6D0*LamGev**5*Mu**2 + 4D0*LamGev**3*Mu**4 - 8D0*LamGev*Mu**6 + &
       8D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**7*Sqrt(Pi))/(15D0*LamGev**7)
  CS20(I)=(2D0*Mu**2*(LamGev**5 - 4D0*LamGev**3*Mu**2 - 2D0*LamGev*Mu**4 +&
      EXP(Mu**2/LamGev**2)*ErrorF*Mu**3*(5D0*LamGev**2 + 2D0*Mu**2)*Sqrt(Pi)))/(3D0*LamGev**5)
  CS22(I)=(-15D0*LamGev**7 + 2D0*LamGev**5*Mu**2 + 12D0*LamGev**3*Mu**4 + 16D0*LamGev*Mu**6 -&
       4D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**5*(5D0*LamGev**2 + 4D0*Mu**2)*Sqrt(Pi))/(15D0*LamGev**7)
  CSL22(I)=(-3D0*LamGev**5 + 2D0*LamGev**3*Mu**2 - 4D0*LamGev*Mu**4 + 4D0*EXP(Mu**2/LamGev**2)*&
      ErrorF*Mu**5*Sqrt(Pi))/(3D0*LamGev**5)
  CC40(I)=-(Mu**4*(4D0*LamGev**7 - 24D0*LamGev**5*Mu**2 - 26D0*LamGev**3*Mu**4 - 4D0*LamGev*Mu**6 +&
      EXP(Mu**2/LamGev**2)*ErrorF*Mu**3*(35D0*LamGev**4 + 28D0*LamGev**2*Mu**2 + 4D0*Mu**4)*Sqrt(Pi)))/&
      (4D0*LamGev**7)
  CC42(I)=(Mu**2*(3D0*LamGev**9 - 12D0*LamGev**5*Mu**4 - 22D0*LamGev**3*Mu**6 - 4D0*LamGev*Mu**8 +&
      EXP(Mu**2/LamGev**2)*ErrorF*Mu**5*(21D0*LamGev**4 + 24D0*LamGev**2*Mu**2 + 4D0*Mu**4)*Sqrt(Pi)))/&
      (3D0*LamGev**9)
  CC44(I)=(-15D0*LamGev**11 + 8D0*LamGev**5*Mu**6 + 18D0*LamGev**3*Mu**8 + 4D0*LamGev*Mu**10 -&
      EXP(Mu**2/LamGev**2)*ErrorF*Mu**7*(15D0*LamGev**4 + 20D0*LamGev**2*Mu**2 + 4D0*Mu**4)*Sqrt(Pi))/&
      (15D0*LamGev**11)
  CT42(I)=(Mu**2*(15D0*LamGev**9 - 12D0*LamGev**7*Mu**2 + 12D0*LamGev**5*Mu**4 - 32D0*LamGev**3*Mu**6 -&
       8D0*LamGev*Mu**8 + 4D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**7*(9D0*LamGev**2 + 2D0*Mu**2)*&
      Sqrt(Pi)))/(15D0*LamGev**9)
  CT44(I)=(-105D0*LamGev**11 + 12D0*LamGev**7*Mu**4 - 16D0*LamGev**5*Mu**6 + 48D0*LamGev**3*Mu**8 +&
       16D0*LamGev*Mu**10 - 8D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**9*(7D0*LamGev**2 + 2D0*Mu**2)*&
      Sqrt(Pi))/(105D0*LamGev**11)
  CS40(I)=-(Mu**4*(4D0*LamGev**7 - 24D0*LamGev**5*Mu**2 - 26D0*LamGev**3*Mu**4 - 4D0*LamGev*Mu**6 +&
      EXP(Mu**2/LamGev**2)*ErrorF*Mu**3*(35D0*LamGev**4 + 28D0*LamGev**2*Mu**2 + 4D0*Mu**4)*Sqrt(Pi)))/&
      (6D0*LamGev**7)
  CS42(I)=(Mu**2*(15D0*LamGev**9 - 4D0*LamGev**7*Mu**2 - 36D0*LamGev**5*Mu**4 - 84D0*LamGev**3*Mu**6 - &
       16D0*LamGev*Mu**8 + 2D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**5*(35D0*LamGev**4 + 46D0*LamGev**2*Mu**2 +&
       8D0*Mu**4)*Sqrt(Pi)))/(15D0*LamGev**9)
  CS44(I)=(-105D0*LamGev**11 + 4D0*LamGev**7*Mu**4 + 32D0*LamGev**5*Mu**6 + 100D0*LamGev**3*Mu**8 + &
       24D0*LamGev*Mu**10 - 2D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**7*(35D0*LamGev**4 + 56D0*LamGev**2*Mu**2 +&
       12D0*Mu**4)*Sqrt(Pi))/(105D0*LamGev**11)
  CSL42(I)=(3D0*LamGev**7*Mu**2 - 4D0*LamGev**5*Mu**4 + 12D0*LamGev**3*Mu**6 + 4D0*LamGev*Mu**8 -&
       2D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**7*(7D0*LamGev**2 + 2D0*Mu**2)*Sqrt(Pi))/(3D0*LamGev**7)
  CSL44(I)=(-15D0*LamGev**9 + 4D0*LamGev**5*Mu**4 - 16D0*LamGev**3*Mu**6 - 8D0*LamGev*Mu**8 + &
       4D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**7*(5D0*LamGev**2 + 2D0*Mu**2)*Sqrt(Pi))/(15D0*LamGev**9)
END DO

END SUBROUTINE INITSUBTR
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE INITSPECTRAL2PI(OSTAT)
IMPLICIT NONE
INTEGER                    ::OSTAT,I
REAL(KIND(0.0D0))          ::MU,MUQ,RHOA,RHOL,&
                             MPIQ,OMQ,RR,TQ,&
                             C1,C2,C3,C4,D1PD2,D3,D5,D14MD15,E14,E17,E19,E21,E22

ETACQ2=0D0
RHOSQ2=0D0
RHOCQ3=0D0
ETASQ3=0D0
RHOCQ4=0D0
ETACQ4=0D0
RHOSQ4=0D0
ETASQ4=0D0
RHOCQ4REL=0D0
ETACQ4REL=0D0
RHOSQ4REL=0D0
ETASQ4REL=0D0
RHOSLQ4REL=0D0
ETASLQ4REL=0D0
RHOCQ5=0D0
ETACQ5=0D0
RHOSQ5=0D0
ETASQ5=0D0
RHOCQ5REL=0D0
ETACQ5REL=0D0
RHOSQ5REL=0D0
ETASQ5REL=0D0
RHOSLQ5REL=0D0
ETASLQ5REL=0D0

MPIQ=MPI**2
IF (OSTAT .EQ. 2) THEN
  C1=C1N2LO
  C3=C3N2LO
  C4=C4N2LO
ELSE
  IF (OSTAT .EQ. 3) THEN
    C1=C1N3LO
    C2=C2N3LO
    C3=C3N3LO
    C4=C4N3LO
    D1PD2=D1PD2N3LO
    D3=D3N3LO
    D5=D5N3LO
    D14MD15=D14MD15N3LO
  ELSE
    IF (OSTAT .GE. 4) THEN
      C1=C1N4LO
      C2=C2N4LO
      C3=C3N4LO
      C4=C4N4LO
      D1PD2=D1PD2N4LO
      D3=D3N4LO
      D5=D5N4LO
      D14MD15=D14MD15N4LO
      E14=E14N4LO
      E17=E17N4LO
      E19=E19N4LO
      E21=E21N4LO
      E22=E22N4LO
    END IF
  END IF
END IF

IF (OSTAT .GE. 1) THEN
   DO I=0,NMU
      MU=MUP(I)
      MUQ=MU**2
      RHOL=-PI/(2D0*MU)*SQRT(MU**2-4D0*MPI**2)
      ETACQ2(I)=-RHOL/(384D0*PI**2*FPI**4)*(4D0*MPIQ*(5D0*GA**4-4D0*GA**2-1D0)-MUQ*&
          (23D0*GA**4-10D0*GA**2-1D0)+48D0*GA**4*MPI**4/(4D0*MPIQ-MUQ))
      RHOSQ2(I)=-MUQ*3D0*GA**4/(64D0*PI**2*FPI**4)*RHOL
   END DO
   IF (OSTAT .GE. 2) THEN
      DO I=0,NMU
         MU=MUP(I)
         MUQ=MU**2
         RHOA=PI/(4D0*MU)
         RHOCQ3(I)=-3D0*GA**2/(16D0*PI*FPI**4)*(2D0*MPIQ*&
               (2D0*C1-C3)+MUQ*C3)*(2D0*MPIQ-MUQ)*RHOA
         ETASQ3(I)=-MUQ*GA**2/(32D0*PI*FPI**4)*C4*(4D0*MPIQ-MUQ)*RHOA
      END DO
      IF (OSTAT .GE. 3) THEN
    DO I=0,NMU
      MU=MUP(I)
      MUQ=MU**2
      OMQ=-MU**2+4D0*MPI**2
      RHOA=PI/(4D0*MU)
      RHOL=-PI/(2D0*MU)*SQRT(MU**2-4D0*MPI**2)
      RR=0.5D0*SQRT(MUQ-4D0*MPIQ)
      TQ=MUQ-2D0*MPIQ
      RHOCQ4(I)=3D0/(16D0*PI**2*FPI**4)*RHOL*((C2/6D0*OMQ+C3*(2*MPIQ-MUQ)-4D0*C1*MPIQ)**2+C2**2/(45D0)*OMQ**2)&
               -3D0*GA**4*(MUQ-2D0*MPIQ)/(PI*MU*(4D0*FPI)**6)*((MPIQ-2D0*MUQ)*(2D0*MPI+(2D0*MPIQ-MUQ)/(2D0*MU)&
                                                               *LOG((MU+2D0*MPI)/(MU-2D0*MPI)))+4D0*GA**2*MPI*(2D0*MPIQ-MUQ))
      ETASQ4(I)=(C4**2/(96D0*PI**2*FPI**4)*OMQ*RHOL&
           -GA**4*(MUQ-4D0*MPIQ)/(MUQ*PI*(4D0*FPI)**6)*((MPIQ-MUQ/4)*LOG((MU+2D0*MPI)/(MU-2D0*MPI))+(1D0+2D0*GA**2)*MU*MPI))&
           *MUQ
      RHOSQ4(I)=-(GA**2*RR**3*MU/(8D0*FPI**4*PI)*D14MD15-2D0*GA**6*MU*RR**3/(8D0*PI*FPI**2)**3*(1D0/9D0-J1(MU)+J2(MU)))
      ETACQ4(I)=RR*TQ/(24D0*FPI**4*MU*PI)*(2D0*(GA**2-1D0)*RR**2-3D0*GA**2*TQ)*D1PD2&
               +RR**3/(60D0*FPI**4*MU*PI)*(6D0*(GA**2-1D0)*RR**2-5D0*GA**2*TQ)*D3&
               -RR*MPIQ/(6D0*FPI**4*MU*PI)*(2D0*(GA**2-1D0)*RR**2-3D0*GA**2*TQ)*D5&
               -1D0/(92160D0*FPI**6*MUQ*PI**3)*(-320D0*(1D0+2D0*GA**2)**2*MPI**6+240D0*(1D0+6D0*GA**2+8D0*GA**4)*MPI**4*MUQ&
                                                -60D0*GA**2*(8D0+15D0*GA**2)*MPIQ*MU**4&
                                                +(-4D0+29D0*GA**2+122D0*GA**4+3D0*GA**6)*MU**6)*LOG((2D0*RR+MU)/(2D0*MPI))&
               -RR/(2700D0*MU*(8D0*PI*FPI**2)**3)*(-16D0*(171D0+2D0*GA**2*(1D0+GA**2)*(327D0+49D0*GA**2))*MPI**4&
                                                   +4D0*(-73D0+1748D0*GA**2+2549D0*GA**4+726D0*GA**6)*MPIQ*MUQ&
                                                   -(-64D0+389D0*GA**2+1782D0*GA**4+1093D0*GA**6)*MU**4)&
               +2D0*RR/(3D0*MU*(8D0*PI*FPI**2)**3)*(GA**6*TQ**2*J1(MU)-2D0*GA**4*(2D0*GA**2-1D0)*RR**2*TQ*J2(MU))
      RHOCQ4REL(I)=3D0*GA**4/(512D0*PI*M*FPI**4)*(-3D0*(4D0*MPI**4-MU**4)*RHOA)
      ETACQ4REL(I)=GA**2/(128D0*PI*M*FPI**4)*(&
                   -(4D0*MPIQ-2D0*MUQ-GA**2*(7D0*MPIQ-4.5D0*MUQ))*(2D0*MPIQ-MUQ)*RHOA)
      RHOSQ4REL(I)=(9D0*GA**4/(512D0*PI*M*FPI**4)*(4D0*MPIQ-1.5D0*MUQ)*RHOA)*MUQ
      ETASQ4REL(I)=(-GA**2/(256D0*PI*M*FPI**4)*(8D0*MPIQ-2D0*MUQ-GA**2*(4D0*MPIQ-1.5D0*MUQ))*RHOA)*MUQ
      RHOSLQ4REL(I)=-3D0*GA**4/(64D0*PI*M*FPI**4)*(2D0*MPIQ-MUQ)*RHOA
      ETASLQ4REL(I)=-GA**2*(1D0-GA**2)/(64D0*PI*M*FPI**4)*(4D0*MPIQ-MUQ)*RHOA
      RHOCQ4REL(I)=RHOCQ4REL(I)+3D0*GA**4/(512D0*PI*M*FPI**4)*(2D0*MPI**2-MU**2)**2*RHOA
      ETACQ4REL(I)=ETACQ4REL(I)-GA**4/(256D0*PI*M*FPI**4)*(2D0*MPI**2-MU**2)**2*RHOA
      RHOSQ4REL(I)=RHOSQ4REL(I)-(3D0*GA**4/(1024D0*PI*M*FPI**4)*(4D0*MPI**2-MU**2)*RHOA)*MUQ
      ETASQ4REL(I)=ETASQ4REL(I)+(GA**4/(512D0*PI*M*FPI**4)*(4D0*MPI**2-MU**2)*RHOA)*MUQ
      RHOCQ5REL(I)=-GA**2*RHOL/(32D0*PI**2*M*FPI**4)*((C2-6D0*C3)*MU**4-4D0*(6D0*C1+C2-3D0*C3)*MPIQ*MUQ&
                                              +6D0*(C2-2D0*C3)*MPI**4+24D0*(2D0*C1+C3)*MPI**6/(4D0*MPI**2-MUQ))
      ETACQ5REL(I)=C4/(192D0*PI**2*M*FPI**4)*MUQ*OMQ*RHOL&
                  +C4*GA**2/(192D0*PI**2*M*FPI**4)*MUQ*(8D0*MPIQ-5D0*MUQ)*RHOL
      ETASQ5REL(I)=(C4/(192D0*PI**2*M*FPI**4)*OMQ*RHOL&
                  -C4*GA**2/(192D0*PI**2*M*FPI**4)*(16D0*MPIQ-7D0*MUQ)*RHOL)*MUQ
      RHOSLQ5REL(I)=-C2*GA**2/(16D0*PI**2*M*FPI**4)*OMQ*RHOL
      ETASLQ5REL(I)=C4/(96D0*PI**2*M*FPI**4)*OMQ*RHOL&
           +C4*GA**2/(96D0*PI**2*M*FPI**4)*(8D0*MPIQ-5D0*MUQ)*RHOL
   END DO
   IF (OSTAT .GE. 4) THEN
      DO I=0,NMU
        MU=MUP(I)
        MUQ=MU**2
        OMQ=-MU**2+4D0*MPI**2
        RHOA=PI/(4D0*MU)
        RHOL=-PI/(2D0*MU)*SQRT(MU**2-4D0*MPI**2)
        RR=0.5D0*SQRT(MUQ-4D0*MPIQ)
        TQ=MUQ-2D0*MPIQ
        RHOCQ5(I)=2D0*((GA**2*(2D0*MPI**2 - MU**2)*(MU*(72D0*C1*(MPI**4 - 2D0*MPI**2*MU**2) + C2*(-24D0*MPI**4 + &
              53D0*MPI**2*MU**2 - 10D0*MU**4) +&
              18D0*(C3*(-2D0*MPI**4 + 5D0*MPI**2*MU**2 - 2D0*MU**4) +&
              128D0*FPI**2*(E14*(-2D0*MPI**2 + MU**2)**2 + MPI**2*(4D0*E19*MPI**2 - 2D0*E19*MU**2 + E22*MU**2))*Pi**2)) -&
              6D0*(MPI**2 - 2D0*MU**2)*(24D0*C1*MPI**2 + C2*(-4D0*MPI**2 + MU**2) + 6D0*C3*(-2D0*MPI**2 + MU**2))*RR*&
              Log((MU + 2D0*RR)/(MU - 2D0*RR))))/(24576D0*FPI**6*MU**2*Pi**2))
        RHOCQ5(I)=RHOCQ5(I)+2D0*((48D0*GA**2*MPI*(MPI**2 - 2D0*MU**2)*RR**2*(6D0*(2D0*C1 - C3)*MPI**2 + 3D0*C3*MU**2 + &
              2D0*C2*RR**2) + &
              GA**4*(1536D0*(2D0*C1 - C3)*MPI**7 - 16D0*(84D0*C1 + 5D0*C2 - 42D0*C3)*MPI**6*MU - 192D0*(6D0*C1 - &
              7D0*C3)*MPI**5*MU**2 + &
              8D0*(84D0*C1 + 5D0*C2 - 84D0*C3)*MPI**4*MU**3 - 288D0*C3*MPI**3*MU**4 + (-36D0*C1 - 5D0*C2 + &
              186D0*C3)*MPI**2*MU**5 - &
              9D0*C3*MU**7 - 8D0*(64D0*C2*MPI**5 + (-12D0*C1 - 5D0*C2 + 6D0*C3)*MPI**4*MU - 40D0*C2*MPI**3*MU**2 + &
              (4D0*C2 - 3D0*C3)*MPI**2*MU**3 + C2*MU**5)*RR**2) + &
              12D0*MU*RR**2*(3D0*(4D0*C1 - C2 - 2D0*C3)*MPI**4 + 3D0*C3*MPI**2*MU**2 + &
              2D0*((12D0*C1 + C2 - 6D0*C3)*MPI**2 + 3D0*C3*MU**2)*RR**2 + 8D0*C2*RR**4))/(24576D0*FPI**6*MU*Pi**2*RR) + &
              (GA**2*(2D0*MPI**4 - 5D0*MPI**2*MU**2 + 2D0*MU**4)*RR*(6D0*(2D0*C1 - C3)*MPI**2 + 3D0*C3*MU**2 + 2D0*C2*RR**2)*&
              Log(1D0 + (4D0*MPI)/(-2D0*MPI + MU)))/(2048D0*FPI**6*MU**2*Pi**2) + &
              (MPI**2*(3D0*(-4D0*C1 + C2 + 2D0*C3)*MPI**4 - 3D0*C3*MPI**2*MU**2 + &
              2D0*GA**4*((28D0*C1 + 9D0*C2 - 14D0*C3)*MPI**4 - 4D0*C3*MU**4 + 4D0*(-8D0*C1 + C2 + 4D0*C3)*MPI**2*RR**2 - &
              MU**2*((16D0*C1 + 4D0*C2 - 15D0*C3)*MPI**2 + 8D0*C3*RR**2)))*Log((MU/2D0 + RR)/(MU/2D0 - RR)))/&
              (2048D0*FPI**6*MU*Pi**2))
        ETACQ5(I)=2D0*((-((-3D0*MU*RR**2*(-3D0*(-4D0*C1 + C2 + C3)*MPI**4 + 2D0*(12D0*C1 + C2 + C3)*MPI**2*RR**2 + &
              8D0*(C2 + C3)*RR**4) + &
              (C3 - C4)*GA**4*(12D0*MPI**2*(2D0*MPI - MU)*(-2D0*MPI**2 + MU**2)**2 + &
              (-192D0*MPI**5 + 87D0*MPI**4*MU + 96D0*MPI**3*MU**2 - 54D0*MPI**2*MU**3 + 6D0*MU**5)*RR**2 - &
              2D0*(16D0*MPI**3 - 19D0*MPI**2*MU + 6D0*MU**3)*RR**4 + 8D0*MU*RR**6) + &
              GA**2*RR**2*(48D0*(-C3 + C4)*MPI**3*MU**2 + 32D0*(C3 - C4)*MPI**3*(3D0*MPI**2 + RR**2) -&
              3D0*MU**3*((24D0*C1 + 3D0*C2 - 2D0*C3 + 5D0*C4)*MPI**2 + 2D0*(3D0*C2 + 2D0*C3 + C4)*RR**2) + &
              MU*(3D0*(60D0*C1 + 3D0*C2 - 8D0*C3 + 11D0*C4)*MPI**4 + 2D0*(36D0*C1 + 21D0*C2 + 8D0*C3 + 13D0*C4)*MPI**2*RR**2 + &
              8D0*(3D0*C2 + 2D0*C3 + C4)*RR**4)))/RR) + &
              3D0*((3D0*(C2 + C3) - 12D0*C1*(1D0 + 3D0*GA**2) + GA**2*(3D0*C2 + C3*(8D0 - 35D0*GA**2) + 5D0*C4*(-1D0 + &
              7D0*GA**2)))*MPI**6 + &
              3D0*GA**2*(8D0*C1 - C2 - 2*C3 + C4 + 10D0*C3*GA**2 - 10D0*C4*GA**2)*MPI**4*MU**2 + &
              6D0*(-C3 + C4)*GA**4*MPI**2*MU**4)*&
              Log(-((MU + 2D0*RR)/(-MU + 2D0*RR))))/(9216D0*FPI**6*MU*Pi**2))
        RHOSQ5(I)=2D0*(((C3 - C4)*GA**4*MU*(-2D0*MPI**2*(-2D0*MPI + MU)**2*(2D0*MPI + MU) + &
              (16D0*MPI**3 - 9D0*MPI**2*MU + MU**3)*RR**2 - &
              2D0*MU*RR**4 + 3D0*MPI**2*(-5D0*MPI**2 + MU**2)*RR*Log(-((MU + 2D0*RR)/(-MU + &
              2D0*RR)))))/(2048D0*FPI**6*Pi**2*RR))
        ETASQ5(I)=2D0*((GA**2*(4D0*MPI**2 - MU**2)*(MU*(C4*(12D0*(2D0 + 9D0*GA**2)*MPI**2 - 5D0*MU**2) - &
              1152D0*FPI**2*(2D0*E17*MPI**2 + 2D0*E21*MPI**2 - E17*MU**2)*Pi**2) + 24D0*C4*RR**3*Log((MU + &
              2D0*RR)/(MU - 2D0*RR))))/ &
              (73728D0*FPI**6*Pi**2))
        ETASQ5(I)=ETASQ5(I)+2D0*((C4*GA**2*(MU*(2D0*GA**2*MPI**2*(-2D0*MPI + MU)**2*(2D0*MPI + MU) - &
              (4D0*(-3D0 + 4D0*GA**2)*MPI**3 - 9D0*GA**2*MPI**2*MU + 3D0*MPI*MU**2 + GA**2*MU**3)*RR**2 + &
              2D0*(2D0*MPI + GA**2*MU)*RR**4 &
              ) + RR**4*(3D0*(-4D0*MPI**2 + MU**2) - 4D0*RR**2)*Log(1D0 + (4D0*MPI)/(-2D0*MPI + MU)) + &
              3D0*GA**2*MPI**2*MU*(5D0*MPI**2 - MU**2)*RR*Log(-((MU + 2D0*RR)/(-MU + &
              2D0*RR)))))/(6144D0*FPI**6*Pi**2*RR))
     END DO
  END IF
END IF
END IF
END IF

END SUBROUTINE INITSPECTRAL2PI
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE COMBINESPECTRALFUN(OSTAT,CUTNUMQ)
IMPLICIT NONE
INTEGER                    ::I,CUTNUMQ,OSTAT
REAL(KIND(0.0D0))          ::LAMGEV,MU,REG,FAKTCONVNORB,&
                             BI0,DI0,BI1,DI1,BK0,DK0,BK1,DK1,X

RHOC=0D0
RHOS=0D0
RHOSL=0D0
RHOT=0D0
ETAC=0D0
ETAS=0D0
ETASL=0D0
ETAT=0D0
RHOCSUBTR=0D0
RHOSSUBTR=0D0
RHOTSUBTR=0D0
RHOSLSUBTR=0D0
ETACSUBTR=0D0
ETASSUBTR=0D0
ETATSUBTR=0D0
ETASLSUBTR=0D0

LAMGEV=CUTQ(CUTNUMQ)*SQRT(2D0)
FAKTCONVNORB=-2D0

DO I=0,NMU
  MU=MUP(I)
  IF (OSTAT .GE. 1) THEN
    ETAC(I)=ETACQ2(I)*MU
    ETACSUBTR(1,I)=(-1D0/MU+CC20(I)/MU**3)*ETACQ2(I)
    ETACSUBTR(2,I)=(1D0/MU**3+CC22(I)/MU**3)*ETACQ2(I)
    RHOS(I)=RHOSQ2(I)*MU
    RHOSSUBTR(1,I)=(-1D0/MU+CS20(I)/MU**3)*RHOSQ2(I)
    RHOSSUBTR(2,I)=(1D0/MU**3+CS22(I)/MU**3)*RHOSQ2(I)
    RHOT(I)=RHOSQ2(I)/MU
    RHOTSUBTR(1,I)=-(1D0/MU**3+CT22(I)/MU**3)*RHOSQ2(I)
    IF (OSTAT .GE. 2) THEN
      RHOC(I)=RHOCQ3(I)*MU
      RHOCSUBTR(1,I)=(-1D0/MU+CC20(I)/MU**3)*RHOCQ3(I)
      RHOCSUBTR(2,I)=(1D0/MU**3+CC22(I)/MU**3)*RHOCQ3(I)
      ETAS(I)=ETASQ3(I)*MU
      ETASSUBTR(1,I)=(-1D0/MU+CS20(I)/MU**3)*ETASQ3(I)
      ETASSUBTR(2,I)=(1D0/MU**3+CS22(I)/MU**3)*ETASQ3(I)
      ETAT(I)=ETASQ3(I)/MU
      ETATSUBTR(1,I)=-(1D0/MU**3+CT22(I)/MU**3)*ETASQ3(I)
      IF (OSTAT .GE. 3) THEN
        RHOC(I)=RHOC(I)+(RHOCQ4(I)+RHOCQ4REL(I)+RHOCQ5REL(I))*MU
        RHOCSUBTR(1,I)=RHOCSUBTR(1,I)+(-(RHOCQ4(I)+RHOCQ4REL(I)+RHOCQ5REL(I))/MU&
                      -CC40(I)*RHOCQ4(I)/MU**5+CC20(I)*RHOCQ4REL(I)/MU**3-CC40(I)*RHOCQ5REL(I)/MU**5)
        RHOCSUBTR(2,I)=RHOCSUBTR(2,I)+((RHOCQ4(I)+RHOCQ4REL(I)+RHOCQ5REL(I))/MU**3&
                      -CC42(I)*RHOCQ4(I)/MU**5+CC22(I)*RHOCQ4REL(I)/MU**3-CC42(I)*RHOCQ5REL(I)/MU**5)
        RHOCSUBTR(3,I)=RHOCSUBTR(3,I)+(-(RHOCQ4(I)+RHOCQ5REL(I))/MU**5&
                      -CC44(I)*RHOCQ4(I)/MU**5-CC44(I)*RHOCQ5REL(I)/MU**5)
        RHOS(I)=RHOS(I)+(RHOSQ4(I)+RHOSQ4REL(I)+RHOSQ5REL(I))*MU
        RHOSSUBTR(1,I)=RHOSSUBTR(1,I)+(-(RHOSQ4(I)+RHOSQ4REL(I)+RHOSQ5REL(I))/MU&
                      -CS40(I)*RHOSQ4(I)/MU**5+CS20(I)*RHOSQ4REL(I)/MU**3-CS40(I)*RHOSQ5REL(I)/MU**5)
        RHOSSUBTR(2,I)=RHOSSUBTR(2,I)+((RHOSQ4(I)+RHOSQ4REL(I)+RHOSQ5REL(I))/MU**3&
                      -CS42(I)*RHOSQ4(I)/MU**5+CS22(I)*RHOSQ4REL(I)/MU**3-CS42(I)*RHOSQ5REL(I)/MU**5)
        RHOSSUBTR(3,I)=RHOSSUBTR(3,I)+(-(RHOSQ4(I)+RHOSQ5REL(I))/MU**5&
                      -CS44(I)*RHOSQ4(I)/MU**5-CS44(I)*RHOSQ5REL(I)/MU**5)
        RHOT(I)=RHOT(I)+(RHOSQ4(I)+RHOSQ4REL(I)+RHOSQ5REL(I))/MU
        RHOTSUBTR(1,I)=RHOTSUBTR(1,I)+(-(RHOSQ4(I)+RHOSQ4REL(I)+RHOSQ5REL(I))/MU**3&
                      +CT42(I)*RHOSQ4(I)/MU**5-CT22(I)*RHOSQ4REL(I)/MU**3+CT42(I)*RHOSQ5REL(I)/MU**5)
        RHOTSUBTR(2,I)=RHOTSUBTR(2,I)+((RHOSQ4(I)+RHOSQ5REL(I))/MU**5&
                      +CT44(I)*RHOSQ4(I)/MU**5+CT44(I)*RHOSQ5REL(I)/MU**5)
        RHOSL(I)=RHOSL(I)+(RHOSLQ4REL(I)+RHOSLQ5REL(I))*MU
        RHOSLSUBTR(1,I)=RHOSLSUBTR(1,I)+(-(RHOSLQ4REL(I)+RHOSLQ5REL(I))/MU&
                      -CSL22(I)*RHOSLQ4REL(I)/MU+CSL42(I)*RHOSLQ5REL(I)/MU**3)
        RHOSLSUBTR(2,I)=RHOSLSUBTR(2,I)+(RHOSLQ5REL(I)/MU**3&
                      +CSL44(I)*RHOSLQ5REL(I)/MU**3)
        ETAC(I)=ETAC(I)+(ETACQ4(I)+ETACQ4REL(I)+ETACQ5REL(I))*MU
        ETACSUBTR(1,I)=ETACSUBTR(1,I)+(-(ETACQ4(I)+ETACQ4REL(I)+ETACQ5REL(I))/MU&
                      -CC40(I)*ETACQ4(I)/MU**5+CC20(I)*ETACQ4REL(I)/MU**3-CC40(I)*ETACQ5REL(I)/MU**5)
        ETACSUBTR(2,I)=ETACSUBTR(2,I)+((ETACQ4(I)+ETACQ4REL(I)+ETACQ5REL(I))/MU**3&
                      -CC42(I)*ETACQ4(I)/MU**5+CC22(I)*ETACQ4REL(I)/MU**3-CC42(I)*ETACQ5REL(I)/MU**5)
        ETACSUBTR(3,I)=ETACSUBTR(3,I)+(-(ETACQ4(I)+ETACQ5REL(I))/MU**5&
                      -CC44(I)*ETACQ4(I)/MU**5-CC44(I)*ETACQ5REL(I)/MU**5)
        ETAS(I)=ETAS(I)+(ETASQ4(I)+ETASQ4REL(I)+ETASQ5REL(I))*MU
        ETASSUBTR(1,I)=ETASSUBTR(1,I)+(-(ETASQ4(I)+ETASQ4REL(I)+ETASQ5REL(I))/MU&
                      -CS40(I)*ETASQ4(I)/MU**5+CS20(I)*ETASQ4REL(I)/MU**3-CS40(I)*ETASQ5REL(I)/MU**5)
        ETASSUBTR(2,I)=ETASSUBTR(2,I)+((ETASQ4(I)+ETASQ4REL(I)+ETASQ5REL(I))/MU**3&
                      -CS42(I)*ETASQ4(I)/MU**5+CS22(I)*ETASQ4REL(I)/MU**3-CS42(I)*ETASQ5REL(I)/MU**5)
        ETASSUBTR(3,I)=ETASSUBTR(3,I)+(-(ETASQ4(I)+ETASQ5REL(I))/MU**5&
                      -CS44(I)*ETASQ4(I)/MU**5-CS44(I)*ETASQ5REL(I)/MU**5)
        ETAT(I)=ETAT(I)+(ETASQ4(I)+ETASQ4REL(I)+ETASQ5REL(I))/MU
        ETATSUBTR(1,I)=ETATSUBTR(1,I)+(-(ETASQ4(I)+ETASQ4REL(I)+ETASQ5REL(I))/MU**3&
                      +CT42(I)*ETASQ4(I)/MU**5-CT22(I)*ETASQ4REL(I)/MU**3+CT42(I)*ETASQ5REL(I)/MU**5)
        ETATSUBTR(2,I)=ETATSUBTR(2,I)+((ETASQ4(I)+ETASQ5REL(I))/MU**5&
                      +CT44(I)*ETASQ4(I)/MU**5+CT44(I)*ETASQ5REL(I)/MU**5)
        ETASL(I)=ETASL(I)+(ETASLQ4REL(I)+ETASLQ5REL(I))*MU
        ETASLSUBTR(1,I)=ETASLSUBTR(1,I)+(-(ETASLQ4REL(I)+ETASLQ5REL(I))/MU&
                      -CSL22(I)*ETASLQ4REL(I)/MU+CSL42(I)*ETASLQ5REL(I)/MU**3)
        ETASLSUBTR(2,I)=ETASLSUBTR(2,I)+(ETASLQ5REL(I)/MU**3&
                      +CSL44(I)*ETASLQ5REL(I)/MU**3)
        IF (OSTAT .GE. 4) THEN
          RHOC(I)=RHOC(I)+RHOCQ5(I)*MU
          RHOCSUBTR(1,I)=RHOCSUBTR(1,I)+(-RHOCQ5(I)/MU-CC40(I)*RHOCQ5(I)/MU**5)
          RHOCSUBTR(2,I)=RHOCSUBTR(2,I)+(RHOCQ5(I)/MU**3-CC42(I)*RHOCQ5(I)/MU**5)
          RHOCSUBTR(3,I)=RHOCSUBTR(3,I)+(-RHOCQ5(I)/MU**5-CC44(I)*RHOCQ5(I)/MU**5)
          RHOS(I)=RHOS(I)+RHOSQ5(I)*MU
          RHOSSUBTR(1,I)=RHOSSUBTR(1,I)+(-RHOSQ5(I)/MU-CS40(I)*RHOSQ5(I)/MU**5)
          RHOSSUBTR(2,I)=RHOSSUBTR(2,I)+(RHOSQ5(I)/MU**3-CS42(I)*RHOSQ5(I)/MU**5)
          RHOSSUBTR(3,I)=RHOSSUBTR(3,I)+(-RHOSQ5(I)/MU**5-CS44(I)*RHOSQ5(I)/MU**5)
          RHOT(I)=RHOT(I)+RHOSQ5(I)/MU
          RHOTSUBTR(1,I)=RHOTSUBTR(1,I)+(-RHOSQ5(I)/MU**3+CT42(I)*RHOSQ5(I)/MU**5)
          RHOTSUBTR(2,I)=RHOTSUBTR(2,I)+(RHOSQ5(I)/MU**5+CT44(I)*RHOSQ5(I)/MU**5)
          ETAC(I)=ETAC(I)+ETACQ5(I)*MU
          ETACSUBTR(1,I)=ETACSUBTR(1,I)+(-ETACQ5(I)/MU-CC40(I)*ETACQ5(I)/MU**5)
          ETACSUBTR(2,I)=ETACSUBTR(2,I)+(ETACQ5(I)/MU**3-CC42(I)*ETACQ5(I)/MU**5)
          ETACSUBTR(3,I)=ETACSUBTR(3,I)+(-ETACQ5(I)/MU**5-CC44(I)*ETACQ5(I)/MU**5)
          ETAS(I)=ETAS(I)+ETASQ5(I)*MU
          ETASSUBTR(1,I)=ETASSUBTR(1,I)+(-ETASQ5(I)/MU-CS40(I)*ETASQ5(I)/MU**5)
          ETASSUBTR(2,I)=ETASSUBTR(2,I)+(ETASQ5(I)/MU**3-CS42(I)*ETASQ5(I)/MU**5)
          ETASSUBTR(3,I)=ETASSUBTR(3,I)+(-ETASQ5(I)/MU**5-CS44(I)*ETASQ5(I)/MU**5)
          ETAT(I)=ETAT(I)+ETASQ5(I)/MU
          ETATSUBTR(1,I)=ETATSUBTR(1,I)+(-ETASQ5(I)/MU**3+CT42(I)*ETASQ5(I)/MU**5)
          ETATSUBTR(2,I)=ETATSUBTR(2,I)+(ETASQ5(I)/MU**5+CT44(I)*ETASQ5(I)/MU**5)
        END IF
      END IF
    END IF
  END IF
END DO

DO I=1,NMU
  MU=MUP(I)
  REG=2D0/PI*EXP(-MU**2/LAMGEV**2)*MUW(I)
  FR(I)=SQRT(MUP(0)**2-4D0*MPI**2)/SQRT(MUP(I)**2-4D0*MPI**2)
  RHOCSUBTR(1,I)=(RHOCSUBTR(1,I)-RHOCSUBTR(1,0)*FR(I))*REG
  RHOCSUBTR(2,I)=(RHOCSUBTR(2,I)-RHOCSUBTR(2,0)*FR(I))*REG
  RHOCSUBTR(3,I)=(RHOCSUBTR(3,I)-RHOCSUBTR(3,0)*FR(I))*REG
  RHOSSUBTR(1,I)=(RHOSSUBTR(1,I)-RHOSSUBTR(1,0)*FR(I))*REG
  RHOSSUBTR(2,I)=(RHOSSUBTR(2,I)-RHOSSUBTR(2,0)*FR(I))*REG
  RHOSSUBTR(3,I)=(RHOSSUBTR(3,I)-RHOSSUBTR(3,0)*FR(I))*REG
  RHOTSUBTR(1,I)=(RHOTSUBTR(1,I)-RHOTSUBTR(1,0)*FR(I))*REG
  RHOTSUBTR(2,I)=(RHOTSUBTR(2,I)-RHOTSUBTR(2,0)*FR(I))*REG
  RHOSLSUBTR(1,I)=(RHOSLSUBTR(1,I)-RHOSLSUBTR(1,0)*FR(I))*REG
  RHOSLSUBTR(2,I)=(RHOSLSUBTR(2,I)-RHOSLSUBTR(2,0)*FR(I))*REG
  ETACSUBTR(1,I)=(ETACSUBTR(1,I)-ETACSUBTR(1,0)*FR(I))*REG
  ETACSUBTR(2,I)=(ETACSUBTR(2,I)-ETACSUBTR(2,0)*FR(I))*REG
  ETACSUBTR(3,I)=(ETACSUBTR(3,I)-ETACSUBTR(3,0)*FR(I))*REG
  ETASSUBTR(1,I)=(ETASSUBTR(1,I)-ETASSUBTR(1,0)*FR(I))*REG
  ETASSUBTR(2,I)=(ETASSUBTR(2,I)-ETASSUBTR(2,0)*FR(I))*REG
  ETASSUBTR(3,I)=(ETASSUBTR(3,I)-ETASSUBTR(3,0)*FR(I))*REG
  ETATSUBTR(1,I)=(ETATSUBTR(1,I)-ETATSUBTR(1,0)*FR(I))*REG
  ETATSUBTR(2,I)=(ETATSUBTR(2,I)-ETATSUBTR(2,0)*FR(I))*REG
  ETASLSUBTR(1,I)=(ETASLSUBTR(1,I)-ETASLSUBTR(1,0)*FR(I))*REG
  ETASLSUBTR(2,I)=(ETASLSUBTR(2,I)-ETASLSUBTR(2,0)*FR(I))*REG
  RHOC(I)=RHOC(I)*REG
  RHOS(I)=RHOS(I)*REG
  RHOT(I)=RHOT(I)*REG
  RHOSL(I)=RHOSL(I)*REG
  ETAC(I)=ETAC(I)*REG
  ETAS(I)=ETAS(I)*REG
  ETAT(I)=ETAT(I)*REG
  ETASL(I)=ETASL(I)*REG
  XRHOC(I)=RHOC(0)*FR(I)*REG
  XRHOS(I)=RHOS(0)*FR(I)*REG
  XRHOT(I)=RHOT(0)*FR(I)*REG
  XRHOSL(I)=RHOSL(0)*FR(I)*REG
  XETAC(I)=ETAC(0)*FR(I)*REG
  XETAS(I)=ETAS(0)*FR(I)*REG
  XETAT(I)=ETAT(0)*FR(I)*REG
  XETASL(I)=ETASL(0)*FR(I)*REG
END DO
X=2D0*MPI**2/LAMGEV**2
CALL IK01A(X,BI0,DI0,BI1,DI1,BK0,DK0,BK1,DK1)
RESID=1D0/PI*EXP(-2D0*MPI**2/LAMGEV**2)*BK0*SQRT(MUP(0)**2-4D0*MPI**2)

RHOSL=RHOSL*FAKTCONVNORB
RHOSLSUBTR=RHOSLSUBTR*FAKTCONVNORB
ETASL=ETASL*FAKTCONVNORB
ETASLSUBTR=ETASLSUBTR*FAKTCONVNORB

END SUBROUTINE COMBINESPECTRALFUN
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE TPEP(QPUN,OSTAT,CUTNUMQ,TPEPMOM)
IMPLICIT NONE
INTEGER                    ::I,CUTNUMQ,OSTAT
REAL(KIND(0.0D0))          ::LAMGEV,MU,REG,QPUN,TPEPMOM(NSPIN,NISO),QPUN2,QPUN4,MU2,MU12

TPEPMOM=0D0
QPUN2=QPUN**2
QPUN4=QPUN**4
MU12=MUP(0)**2
LAMGEV=CUTQ(CUTNUMQ)*SQRT(2D0)
REG=EXP(-QPUN2/LAMGEV**2)/(2D0*PI)**3

IF (OSTAT .GE. 1) THEN
  DO I=1,NMU
    MU=MUP(I)
    MU2=MU**2
    TPEPMOM(1,1)=TPEPMOM(1,1)+RHOC(I)/(QPUN2+MU2)+RHOCSUBTR(1,I)+QPUN2*RHOCSUBTR(2,I)+QPUN4*RHOCSUBTR(3,I)&
                             -XRHOC(I)/(QPUN2+MU12)
    TPEPMOM(2,1)=TPEPMOM(2,1)+RHOS(I)/(QPUN2+MU2)+RHOSSUBTR(1,I)+QPUN2*RHOSSUBTR(2,I)+QPUN4*RHOSSUBTR(3,I)&
                             -XRHOS(I)/(QPUN2+MU12)
    TPEPMOM(3,1)=TPEPMOM(3,1)+RHOT(I)/(QPUN2+MU2)+RHOTSUBTR(1,I)+QPUN2*RHOTSUBTR(2,I)&
                             -XRHOT(I)/(QPUN2+MU12)
    TPEPMOM(4,1)=TPEPMOM(4,1)+RHOSL(I)/(QPUN2+MU2)+RHOSLSUBTR(1,I)+QPUN2*RHOSLSUBTR(2,I)&
                             -XRHOSL(I)/(QPUN2+MU12)
    TPEPMOM(1,2)=TPEPMOM(1,2)+ETAC(I)/(QPUN2+MU2)+ETACSUBTR(1,I)+QPUN2*ETACSUBTR(2,I)+QPUN4*ETACSUBTR(3,I)&
                             -XETAC(I)/(QPUN2+MU12)
    TPEPMOM(2,2)=TPEPMOM(2,2)+ETAS(I)/(QPUN2+MU2)+ETASSUBTR(1,I)+QPUN2*ETASSUBTR(2,I)+QPUN4*ETASSUBTR(3,I)&
                             -XETAS(I)/(QPUN2+MU12)
    TPEPMOM(3,2)=TPEPMOM(3,2)+ETAT(I)/(QPUN2+MU2)+ETATSUBTR(1,I)+QPUN2*ETATSUBTR(2,I)&
                             -XETAT(I)/(QPUN2+MU12)
    TPEPMOM(4,2)=TPEPMOM(4,2)+ETASL(I)/(QPUN2+MU2)+ETASLSUBTR(1,I)+QPUN2*ETASLSUBTR(2,I)&
                             -XETASL(I)/(QPUN2+MU12)
  END DO
TPEPMOM(1,1)=TPEPMOM(1,1)+(RHOC(0)/(QPUN2+MU12)+RHOCSUBTR(1,0)+QPUN2*RHOCSUBTR(2,0)+QPUN4*RHOCSUBTR(3,0))*RESID
TPEPMOM(2,1)=TPEPMOM(2,1)+(RHOS(0)/(QPUN2+MU12)+RHOSSUBTR(1,0)+QPUN2*RHOSSUBTR(2,0)+QPUN4*RHOSSUBTR(3,0))*RESID
TPEPMOM(3,1)=TPEPMOM(3,1)+(RHOT(0)/(QPUN2+MU12)+RHOTSUBTR(1,0)+QPUN2*RHOTSUBTR(2,0))*RESID
TPEPMOM(4,1)=TPEPMOM(4,1)+(RHOSL(0)/(QPUN2+MU12)+RHOSLSUBTR(1,0)+QPUN2*RHOSLSUBTR(2,0))*RESID
TPEPMOM(1,2)=TPEPMOM(1,2)+(ETAC(0)/(QPUN2+MU12)+ETACSUBTR(1,0)+QPUN2*ETACSUBTR(2,0)+QPUN4*ETACSUBTR(3,0))*RESID
TPEPMOM(2,2)=TPEPMOM(2,2)+(ETAS(0)/(QPUN2+MU12)+ETASSUBTR(1,0)+QPUN2*ETASSUBTR(2,0)+QPUN4*ETASSUBTR(3,0))*RESID
TPEPMOM(3,2)=TPEPMOM(3,2)+(ETAT(0)/(QPUN2+MU12)+ETATSUBTR(1,0)+QPUN2*ETATSUBTR(2,0))*RESID
TPEPMOM(4,2)=TPEPMOM(4,2)+(ETASL(0)/(QPUN2+MU12)+ETASLSUBTR(1,0)+QPUN2*ETASLSUBTR(2,0))*RESID
END IF

TPEPMOM=TPEPMOM*REG
END SUBROUTINE TPEP
!***************************************************************************************************





!***************************************************************************************************
        SUBROUTINE IK01A(X,BI0,DI0,BI1,DI1,BK0,DK0,BK1,DK1)
!       This subroutine has been adapted by EE
!       The original subroutine is downloaded from http://jin.ece.illinois.edu/
!
!       =========================================================
!       Purpose: Compute modified Bessel functions I0(x), I1(1),
!                K0(x) and K1(x), and their derivatives
!       Input :  x   --- Argument ( x  0 )
!       Output:  BI0 --- I0(x)
!                DI0 --- I0'(x)
!                BI1 --- I1(x)
!                DI1 --- I1'(x)
!                BK0 --- K0(x)
!                DK0 --- K0'(x)
!                BK1 --- K1(x)
!                DK1 --- K1'(x)
!       =========================================================
!
!        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!*EE
IMPLICIT NONE
REAL(KIND(0.0D0))          ::EL,X2,X,BI0,DI0,BI1,DI1,BK0,DK0,BK1,DK1,&
                             R,CA,XR,A,B,CT,W0,WW,CB,XR2,A1
INTEGER                    ::K,K0
        DIMENSION A(12),B(12),A1(8)
           DATA A/0.125D0,7.03125D-2,&
                  7.32421875D-2,1.1215209960938D-1,&
                  2.2710800170898D-1,5.7250142097473D-1,&
                  1.7277275025845D0,6.0740420012735D0,&
                  2.4380529699556D01,1.1001714026925D02,&
                  5.5133589612202D02,3.0380905109224D03/
           DATA B/-0.375D0,-1.171875D-1,&
                  -1.025390625D-1,-1.4419555664063D-1,&
                  -2.7757644653320D-1,-6.7659258842468D-1,&
                  -1.9935317337513D0,-6.8839142681099D0,&
                  -2.7248827311269D01,-1.2159789187654D02,&
                  -6.0384407670507D02,-3.3022722944809D03/
           DATA A1/0.125D0,0.2109375D0,&
                   1.0986328125D0,1.1775970458984D01,&
                   2.1461706161499D02,5.9511522710323D03,&
                   2.3347645606175D05,1.2312234987631D07/
        EL=0.5772156649015329D0
        X2=X*X

        WW=0D0 !*EE

        IF (X.EQ.0.0D0) THEN
           BI0=1.0D0
           BI1=0.0D0
           BK0=1.0D+300
           BK1=1.0D+300
           DI0=0.0D0
           DI1=0.5D0
           DK0=-1.0D+300
           DK1=-1.0D+300
           RETURN
        ELSE IF (X.LE.18.0D0) THEN
           BI0=1.0D0
           R=1.0D0
           DO 15 K=1,50
              R=0.25D0*R*X2/(K*K)
              BI0=BI0+R
              IF (ABS(R/BI0).LT.1.0D-15) GO TO 20
15         CONTINUE
20         BI1=1.0D0
           R=1.0D0
           DO 25 K=1,50
              R=0.25D0*R*X2/(K*(K+1))
              BI1=BI1+R
              IF (ABS(R/BI1).LT.1.0D-15) GO TO 30
25         CONTINUE
30         BI1=0.5D0*X*BI1
        ELSE
           K0=12
           IF (X.GE.35.0) K0=9
           IF (X.GE.50.0) K0=7
           CA=EXP(X)/SQRT(2.0D0*PI*X)
           BI0=1.0D0
           XR=1.0D0/X
           DO 35 K=1,K0
              BI0=BI0+A(K)*XR**K
35         CONTINUE
           BI0=CA*BI0
           BI1=1.0D0
           DO 40 K=1,K0
              BI1=BI1+B(K)*XR**K
40         CONTINUE
           BI1=CA*BI1
        ENDIF
        IF (X.LE.9.0D0) THEN
           CT=-(LOG(X/2.0D0)+EL)
           BK0=0.0D0
           W0=0.0D0
           R=1.0D0
           DO 65 K=1,50
              W0=W0+1.0D0/K
              R=0.25D0*R/(K*K)*X2
              BK0=BK0+R*(W0+CT)
              IF (ABS((BK0-WW)/BK0).LT.1.0D-15) GO TO 70
              WW=BK0
65         CONTINUE
70         BK0=BK0+CT
        ELSE
           CB=0.5D0/X
           XR2=1.0D0/X2
           BK0=1.0D0
           DO 75 K=1,8
              BK0=BK0+A1(K)*XR2**K
75         CONTINUE
           BK0=CB*BK0/BI0
        ENDIF
        BK1=(1.0D0/X-BI1*BK0)/BI0
        DI0=BI1
        DI1=BI0-BI1/X
        DK0=-BK1
        DK1=-BK0-BK1/X
        RETURN
        END SUBROUTINE IK01A
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE OPEP(QPUN,CUTNUMQ,OPEPMOM)
IMPLICIT NONE
INTEGER                    ::CUTNUMQ
REAL(KIND(0.0D0))          ::QPUN,OPEPMOM(NSPIN,NISO),QPUNQ,PROPC,PROPN,CS0C,CS0N,ERRORFC,ERRORFN,ALPHA,LAMGEV

OPEPMOM=0D0
LAMGEV=CUTQ(CUTNUMQ)

QPUNQ=QPUN**2
PROPC=EXP(-(QPUNQ+MPIC**2)/LAMGEV**2)/(MPIC**2+QPUNQ)
PROPN=EXP(-(QPUNQ+MPIN**2)/LAMGEV**2)/(MPIN**2+QPUNQ)
ALPHA=-(GA/(2D0*FPI))**2/(2D0*PI)**3
OPEPMOM(3,2)=ALPHA*PROPC
OPEPMOM(3,3)=4D0*(ALPHA*PROPN-ALPHA*PROPC)
ERRORFN=ERRORFCOM(MPIN/LAMGEV)
ERRORFC=ERRORFCOM(MPIC/LAMGEV)
CS0N=(Alpha*(-((LamGev*(LamGev**2 - 2*MpiN**2))/EXP(MpiN**2/LamGev**2)) - 2D0*ErrorFN*MpiN**3*Sqrt(Pi)))/(3D0*LamGev**3)
CS0C=(Alpha*(-((LamGev*(LamGev**2 - 2*MpiC**2))/EXP(MpiC**2/LamGev**2)) - 2D0*ErrorFC*MpiC**3*Sqrt(Pi)))/(3D0*LamGev**3)
OPEPMOM(2,2)=CS0C*EXP(-QPUNQ/LAMGEV**2)
OPEPMOM(2,3)=4D0*(CS0N-CS0C)*EXP(-QPUNQ/LAMGEV**2)

END SUBROUTINE OPEP
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE TPEPOLE(QPUN,CUTNUMQ,TPEPPOLMOM)
IMPLICIT NONE
INTEGER                    ::CUTNUMQ
REAL(KIND(0.0D0))          ::QPUN,TPEPPOLMOM(NSPIN,NISO),QPUNQ,CC0,CC2,ERRORF,ALPHA,LAMGEV

TPEPPOLMOM=0D0
LAMGEV=CUTQ(CUTNUMQ)*SQRT(2D0)

QPUNQ=QPUN**2

ERRORF=ERRORFCOM(2D0*MPI/LAMGEV)
ALPHA=3D0*GA**4/(512D0*PI*M*FPI**4)*2D0*MPI**5/(2D0*PI)**3
CC0=(2D0*Alpha*((-2D0*LamGev*(LamGev**2 + 2D0*Mpi**2))/EXP((4D0*Mpi**2)/LamGev**2) +&
     ErrorF*Mpi*(5D0*LamGev**2 + 8D0*Mpi**2)*Sqrt(Pi)))/LamGev**5
CC2=(4D0*Alpha*((LamGev*(LamGev**2 + 4D0*Mpi**2))/EXP((4D0*Mpi**2)/LamGev**2) -&
     ErrorF*Mpi*(3D0*LamGev**2 + 8D0*Mpi**2)*Sqrt(Pi)))/(3D0*LamGev**7)
TPEPPOLMOM(1,1)=ALPHA/(QPUNQ+4D0*MPI**2)*&
     EXP(-(QPUNQ+4D0*MPI**2)/LAMGEV**2)+(CC0+CC2*QPUNQ)*EXP(-QPUNQ/LAMGEV**2)
ALPHA=GA**2/(128D0*PI*M*FPI**4)*3D0*GA**2*MPI**5/(2D0*PI)**3
CC0=(2D0*Alpha*((-2D0*LamGev*(LamGev**2 + 2D0*Mpi**2))/EXP((4D0*Mpi**2)/LamGev**2) +&
     ErrorF*Mpi*(5D0*LamGev**2 + 8D0*Mpi**2)*Sqrt(Pi)))/LamGev**5
CC2=(4D0*Alpha*((LamGev*(LamGev**2 + 4D0*Mpi**2))/EXP((4D0*Mpi**2)/LamGev**2) -&
     ErrorF*Mpi*(3D0*LamGev**2 + 8D0*Mpi**2)*Sqrt(Pi)))/(3D0*LamGev**7)
TPEPPOLMOM(1,2)=ALPHA/(QPUNQ+4D0*MPI**2)*&
     EXP(-(QPUNQ+4D0*MPI**2)/LAMGEV**2)+(CC0+CC2*QPUNQ)*EXP(-QPUNQ/LAMGEV**2)

END SUBROUTINE TPEPOLE
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE INITCONTACTS(OSTAT,FORCE,PPUN1,PPUN2,JMOM,CUTNUMQ,POTENCONT)
IMPLICIT NONE
INTEGER                    ::I,OSTAT,CUTNUMQ,JMOM
REAL(KIND(0.0D0))          ::PPUN1,PPUN2,POTENCONT(6),LAMBDANL,FAKT,CC(26),C1S0Q2NNPP,&
                             CCF(5)
CHARACTER(len=2)           ::FORCE

IF (PPUN1 .GE. QMAX/2D0 .OR. PPUN2 .GE. QMAX/2D0) THEN
  POTENCONT=0D0
  RETURN
END IF

POTENCONT=0D0
LAMBDANL=CUTQ(CUTNUMQ)
FAKT=EXP(-(PPUN1**2+PPUN2**2)/LAMBDANL**2)

SELECT CASE (OSTAT)
CASE (0)
  DO I=1,4
    CC(I)=CLO(I,CUTNUMQ)*FAKT
  END DO
  SELECT CASE (JMOM)
  CASE (0)
    SELECT CASE (FORCE)
    CASE ('np')
      POTENCONT(1)=CC(1)
    CASE ('nn')
      POTENCONT(1)=CC(3)
    CASE ('pp')
      POTENCONT(1)=CC(4)
    END SELECT
  CASE (1)
    POTENCONT(3)=CC(2)
  END SELECT
CASE (1, 2)
  IF (OSTAT .EQ. 1) THEN
    DO I=1,11
      CC(I)=CNLODR(I,CUTNUMQ)*FAKT
    END DO
  ELSE
    DO I=1,11
      CC(I)=CN2LODR(I,CUTNUMQ)*FAKT
    END DO
  END IF
  SELECT CASE (JMOM)
  CASE (0)
    POTENCONT(6)=CC(7)*PPUN1*PPUN2
    SELECT CASE (FORCE)
    CASE ('np')
      POTENCONT(1)=CC(1)+CC(2)*(PPUN1**2+PPUN2**2)
    CASE ('nn')
      POTENCONT(1)=CC(10)+CC(2)*(PPUN1**2+PPUN2**2)
    CASE ('pp')
      POTENCONT(1)=CC(11)+CC(2)*(PPUN1**2+PPUN2**2)
    END SELECT
  CASE (1)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CC(3)*PPUN1*PPUN2
      POTENCONT(2)=CC(8)*PPUN1*PPUN2
      POTENCONT(3)=CC(4)+CC(5)*(PPUN1**2+PPUN2**2)
      POTENCONT(4)=CC(6)*PPUN2**2
      POTENCONT(5)=CC(6)*PPUN1**2
    CASE ('nn', 'pp')
      POTENCONT(2)=CC(8)*PPUN1*PPUN2
    END SELECT
  CASE (2)
    POTENCONT(3)=CC(9)*PPUN1*PPUN2
  END SELECT
CASE (3, 4)
  IF (OSTAT .EQ. 3) THEN
    CC(1)=CN3LODR(1,CUTNUMQ)*FAKT
    CC(2)=CN3LODR(2,CUTNUMQ)*FAKT
    CC(3)=(-2D0*D1S0OFF+CN3LODR(3,CUTNUMQ))*FAKT
    CC(4)=D1S0OFF*FAKT
    DO I=5,9
      CC(I)=CN3LODR(I-1,CUTNUMQ)*FAKT
    END DO
    CC(10)=(-2D0*D3S1OFF+CN3LODR(9,CUTNUMQ))*FAKT
    CC(11)=D3S1OFF*FAKT
    CC(12)=CN3LODR(10,CUTNUMQ)*FAKT
    CC(13)=(DE1OFF+CN3LODR(11,CUTNUMQ))*FAKT
    CC(14)=-DE1OFF*FAKT
    DO I=15,26
      CC(I)=CN3LODR(I-3,CUTNUMQ)*FAKT
    END DO
    C1S0Q2NNPP=CC(2)
  ELSE
    CC(1)=CN4LODR(1,CUTNUMQ)*FAKT
    CC(2)=CN4LODR(2,CUTNUMQ)*FAKT
    CC(3)=(-2D0*D1S0OFF+CN4LODR(3,CUTNUMQ))*FAKT
    CC(4)=D1S0OFF*FAKT
    DO I=5,9
      CC(I)=CN4LODR(I-1,CUTNUMQ)*FAKT
    END DO
    CC(10)=(-2D0*D3S1OFF+CN4LODR(9,CUTNUMQ))*FAKT
    CC(11)=D3S1OFF*FAKT
    CC(12)=CN4LODR(10,CUTNUMQ)*FAKT
    CC(13)=(DE1OFF+CN4LODR(11,CUTNUMQ))*FAKT
    CC(14)=-DE1OFF*FAKT
    DO I=15,26
      CC(I)=CN4LODR(I-3,CUTNUMQ)*FAKT
    END DO
    C1S0Q2NNPP=CN4LODR(24,CUTNUMQ)*FAKT
  END IF
  SELECT CASE (JMOM)
  CASE (0)
    POTENCONT(6)=CC(16)*PPUN1*PPUN2&
                +CC(17)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
    SELECT CASE (FORCE)
    CASE ('np')
      POTENCONT(1)=CC(1)+CC(2)*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    CASE ('nn')
      POTENCONT(1)=CC(25)+C1S0Q2NNPP*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    CASE ('pp')
      POTENCONT(1)=CC(26)+C1S0Q2NNPP*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    END SELECT
  CASE (1)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CC(5)*PPUN1*PPUN2&
                  +CC(6)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(2)=CC(18)*PPUN1*PPUN2&
                  +CC(19)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(3)=CC(8)+CC(9)*(PPUN1**2+PPUN2**2)&
                  +CC(10)*PPUN1**2*PPUN2**2+CC(11)*(PPUN1**4+PPUN2**4)
      POTENCONT(4)=CC(12)*PPUN2**2&
                  +CC(13)*PPUN1**2*PPUN2**2+CC(14)*PPUN2**4
      POTENCONT(5)=CC(12)*PPUN1**2&
                  +CC(13)*PPUN1**2*PPUN2**2+CC(14)*PPUN1**4
      POTENCONT(6)=CC(15)*PPUN1**2*PPUN2**2
    CASE ('nn', 'pp')
      POTENCONT(2)=CC(18)*PPUN1*PPUN2&
                  +CC(19)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
    END SELECT
  CASE (2)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CC(7)*PPUN1**2*PPUN2**2
      POTENCONT(2)=CC(23)*PPUN1**2*PPUN2**2
      POTENCONT(3)=CC(20)*PPUN1*PPUN2&
                  +CC(21)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(4)=CC(22)*PPUN1*PPUN2**3
      POTENCONT(5)=CC(22)*PPUN1**3*PPUN2
    CASE ('nn', 'pp')
      POTENCONT(1)=CC(7)*PPUN1**2*PPUN2**2
      POTENCONT(3)=CC(20)*PPUN1*PPUN2&
                  +CC(21)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(4)=CC(22)*PPUN1*PPUN2**3
      POTENCONT(5)=CC(22)*PPUN1**3*PPUN2
    END SELECT
  CASE (3)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(3)=CC(24)*PPUN1**2*PPUN2**2
    END SELECT
  END SELECT
CASE (5)
  CC(1)=CN4LOPLUSDR(1,CUTNUMQ)*FAKT
  CC(2)=CN4LOPLUSDR(2,CUTNUMQ)*FAKT
  CC(3)=(-2D0*D1S0OFF+CN4LOPLUSDR(3,CUTNUMQ))*FAKT
  CC(4)=D1S0OFF*FAKT
  DO I=5,9
    CC(I)=CN4LOPLUSDR(I-1,CUTNUMQ)*FAKT
  END DO
  CC(10)=(-2D0*D3S1OFF+CN4LOPLUSDR(9,CUTNUMQ))*FAKT
  CC(11)=D3S1OFF*FAKT
  CC(12)=CN4LOPLUSDR(10,CUTNUMQ)*FAKT
  CC(13)=(DE1OFF+CN4LOPLUSDR(11,CUTNUMQ))*FAKT
  CC(14)=-DE1OFF*FAKT
  DO I=15,26
    CC(I)=CN4LOPLUSDR(I-3,CUTNUMQ)*FAKT
  END DO
  C1S0Q2NNPP=CN4LOPLUSDR(24,CUTNUMQ)*FAKT
  CCF(1)=CFDR(1,CUTNUMQ)*FAKT
  CCF(2)=CFDR(2,CUTNUMQ)*FAKT
  CCF(3)=CFDR(3,CUTNUMQ)*FAKT
  CCF(4)=0D0
  CCF(5)=CFDR(4,CUTNUMQ)*FAKT
  SELECT CASE (JMOM)
  CASE (0)
    POTENCONT(6)=CC(16)*PPUN1*PPUN2&
                +CC(17)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
    SELECT CASE (FORCE)
    CASE ('np')
      POTENCONT(1)=CC(1)+CC(2)*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    CASE ('nn')
      POTENCONT(1)=CC(25)+C1S0Q2NNPP*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    CASE ('pp')
      POTENCONT(1)=CC(26)+C1S0Q2NNPP*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    END SELECT
  CASE (1)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CC(5)*PPUN1*PPUN2&
                  +CC(6)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(2)=CC(18)*PPUN1*PPUN2&
                  +CC(19)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(3)=CC(8)+CC(9)*(PPUN1**2+PPUN2**2)&
                  +CC(10)*PPUN1**2*PPUN2**2+CC(11)*(PPUN1**4+PPUN2**4)
      POTENCONT(4)=CC(12)*PPUN2**2&
                  +CC(13)*PPUN1**2*PPUN2**2+CC(14)*PPUN2**4
      POTENCONT(5)=CC(12)*PPUN1**2&
                  +CC(13)*PPUN1**2*PPUN2**2+CC(14)*PPUN1**4
      POTENCONT(6)=CC(15)*PPUN1**2*PPUN2**2
    CASE ('nn', 'pp')
      POTENCONT(2)=CC(18)*PPUN1*PPUN2&
                  +CC(19)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
    END SELECT
  CASE (2)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CC(7)*PPUN1**2*PPUN2**2
      POTENCONT(2)=CC(23)*PPUN1**2*PPUN2**2
      POTENCONT(3)=CC(20)*PPUN1*PPUN2&
                  +CC(21)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(4)=CC(22)*PPUN1*PPUN2**3
      POTENCONT(5)=CC(22)*PPUN1**3*PPUN2
      POTENCONT(6)=CCF(1)*PPUN1**3*PPUN2**3
    CASE ('nn', 'pp')
      POTENCONT(1)=CC(7)*PPUN1**2*PPUN2**2
      POTENCONT(3)=CC(20)*PPUN1*PPUN2&
                  +CC(21)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(4)=CC(22)*PPUN1*PPUN2**3
      POTENCONT(5)=CC(22)*PPUN1**3*PPUN2
      POTENCONT(6)=CCF(1)*PPUN1**3*PPUN2**3
    END SELECT
  CASE (3)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CCF(2)*PPUN1**3*PPUN2**3
      POTENCONT(2)=CCF(3)*PPUN1**3*PPUN2**3
      POTENCONT(3)=CC(24)*PPUN1**2*PPUN2**2
      POTENCONT(4)=CCF(4)*PPUN1**2*PPUN2**4
      POTENCONT(5)=CCF(4)*PPUN1**4*PPUN2**2
    CASE  ('nn', 'pp')
      POTENCONT(2)=CCF(3)*PPUN1**3*PPUN2**3
    END SELECT
  CASE (4)
    POTENCONT(3)=CCF(5)*PPUN1**3*PPUN2**3
  END SELECT
END SELECT

POTENCONT=POTENCONT*10000D0/(2D0*PI)**3

END SUBROUTINE INITCONTACTS
!***************************************************************************************************





!***************************************************************************************************
REAL(KIND(0.0D0))   FUNCTION ERRORFCOM(X)
IMPLICIT NONE
REAL(KIND(0.0D0))          ::X,ERR

CALL ERROR(X,ERR)
ERRORFCOM=1D0-ERR

END FUNCTION ERRORFCOM
!***************************************************************************************************





!***************************************************************************************************
subroutine error ( x, err )
!  This subroutine has been adapted by EE
!  The original subroutine is provided by:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!
!  Parameters:
!
!    Input, real X, the argument.
!
!    Output, real ERR, the function value.
!
  implicit none
  REAL(KIND(0.0D0))          ::c0,eps,er,err,r,x,x2
  integer  k

  eps = 1.0D-15
  x2 = x * x

  if ( abs ( x ) < 3.5D+00 ) then

    er = 1.0D+00
    r = 1.0D+00

    do k = 1, 50
      r = r * x2 / ( k + 0.5D+00 )
      er = er + r
      if ( abs ( r ) <= abs ( er ) * eps ) then
        exit
      end if
    end do

    c0 = 2.0D+00 / sqrt ( pi ) * x * exp ( - x2 )
    err = c0 * er

  else

    er = 1.0D+00
    r = 1.0D+00
    do k = 1, 12
      r = - r * ( k - 0.5D+00 ) / x2
      er = er + r
    end do

    c0 = exp ( - x2 ) / ( abs ( x ) * sqrt ( pi ) )

    err = 1.0D+00 - c0 * er
    if ( x < 0.0D+00 ) then
      err = -err
    end if

  end if

  return
end subroutine error
!***************************************************************************************************





!***************************************************************************************************
REAL(KIND(0.0D0))   FUNCTION J1(MUPUN)
IMPLICIT NONE
INTEGER                    ::I
REAL(KIND(0.0D0))          ::MUPUN,R,VAR

R=0.5D0*SQRT(MUPUN**2-4D0*MPI**2)
J1=0D0

DO I=1,NXP
  VAR=R*XP(I)/MPI
  IF (VAR .GE. 0.001D0) THEN
    J1=J1+(1D0/VAR**2-(1D0+1D0/VAR**2)**1.5D0*LOG(VAR+SQRT(1D0+VAR**2)))*XW(I)
  ELSE
    J1=J1+(-4D0/3D0-VAR**2/5D0+2D0*VAR**4/35D0-8D0*VAR**6/315D0)*XW(I)
  END IF
END DO
END FUNCTION J1
!***************************************************************************************************





!***************************************************************************************************
REAL(KIND(0.0D0))   FUNCTION J2(MUPUN)
IMPLICIT NONE
INTEGER                    ::I
REAL(KIND(0.0D0))          ::MUPUN,R,VAR

R=0.5D0*SQRT(MUPUN**2-4D0*MPI**2)
J2=0D0
DO I=1,NXP
  VAR=R*XP(I)/MPI
  IF (VAR .GE. 0.001D0) THEN
    J2=J2+(1D0/VAR**2-(1D0+1D0/VAR**2)**1.5D0*LOG(VAR+SQRT(1D0+VAR**2)))*XW(I)*XP(I)**2
  ELSE
    J2=J2+(-4D0/3D0-VAR**2/5D0+2D0*VAR**4/35D0-8D0*VAR**6/315D0)*XW(I)*XP(I)**2
  END IF
END DO
END FUNCTION J2
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE INFO(OSTAT,CUTNUMQ)
IMPLICIT NONE
INTEGER                    ::OSTAT,CUTNUMQ

WRITE(*,*)'*******************************************************************************************************'
SELECT CASE (OSTAT)
  CASE (0)
  WRITE(*,*)'   Semilocal momentum-space chiral NN potential with Roy-Steiner piN LECs at LO [Q^0]'
  CASE (1)
  WRITE(*,*)'   Semilocal momentum-space chiral NN potential with Roy-Steiner piN LECs at NLO [Q^2]'
  CASE (2)
  WRITE(*,*)'   Semilocal momentum-space chiral NN potential with Roy-Steiner piN LECs at N2LO [Q^3]'
  CASE (3)
  WRITE(*,*)'   Semilocal momentum-space chiral NN potential with Roy-Steiner piN LECs at N3LO [Q^4]'
  CASE (4)
  WRITE(*,*)'   Semilocal momentum-space chiral NN potential with Roy-Steiner piN LECs at N4LO [Q^5]'
  CASE (5)
  WRITE(*,*)'   Semilocal momentum-space chiral NN potential with Roy-Steiner piN LECs at N4LO [Q^5]'
  WRITE(*,*)'                                 + N5LO [Q^6] contacts in 3F2, 1F3, 3F3, 3F4'
  CASE DEFAULT
  WRITE(*,*)'   WRONG VALUE OF OSTAT!'
  STOP
END SELECT
SELECT CASE (CUTNUMQ)
  CASE (1)
  WRITE(*,*)'   Cutoff value: Lambda = 400 MeV'
  CASE (2)
  WRITE(*,*)'   Cutoff value: Lambda = 450 MeV'
  CASE (3)
  WRITE(*,*)'   Cutoff value: Lambda = 500 MeV'
  CASE (4)
  WRITE(*,*)'   Cutoff value: Lambda = 550 MeV'
  IF (OSTAT .EQ. 3) THEN
     WRITE(*,*)'   CAUTION: UNNATURALLY LARGE LEC D_3S1 SIGNALS THAT THE CUTOFF MAYBE TOO HIGH!!!'
  END IF
  CASE DEFAULT
  WRITE(*,*)'   WRONG VALUE OF CUTNUMQ!'
  STOP
END SELECT
WRITE(*,*)'*******************************************************************************************************'
END SUBROUTINE INFO
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE INITMU()
IMPLICIT NONE
INTEGER                    ::I
REAL(KIND(0.0D0))          ::MUPX(NMU)

CALL TRNSCH(NMU/2,NMU-NMU/2,NMU,LAMMU1,LAMMU2,LAMMU3,MUPX,MUW)
DO I=1,NMU
   MUP(I)=MUPX(I)+2.0D0*MPI
END DO
MUP(0)=(2D0+0.0000000001D0)*MPI

END SUBROUTINE INITMU
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE TRNSCH(NP1,NP2,NP,P1,P2,P3,XP,AP)
!     ===============
!
!     TRNS BELEGT DIE FELDER XP UND AP MIT TRANSFORMIERTEN
!     GAUSS-LEGENDRE-PUNKTEN UND GEWICHTEN
!
!     NP1 PUNKTE WERDEN UEBER DIE HYPERBOLISCHE TRANSFORMATION
!
!     X --> (1.+X) / (1./P1-(1./P1-2./P2)*X)
!
!     AUF DAS INTERVALL (0.;P2) ABGEBILDET, WOBEI
!     NP1/2 PUNKTE IN (0.;P1) UND
!     NP1/2 PUNKTE IN (P1;P2) LIEGEN
!
!     NP2 PUNKTE WERDEN UEBER DIE LINEARE TRANSFORMATION
!
!     X --> (P3+P2)/2. + (P3-P2)/2.*X
!
!     AUF DAS INTERVALL (P2;P3) ABGEBILDET
!
!     NP = NP1 + NP2
!
      IMPLICIT NONE
      INTEGER NP,NP1,NP2,I
      REAL(KIND(0.0D0))  XP1(5000),AP1(5000),XP2(5000),AP2(5000)
      REAL(KIND(0.0D0))  XP(NP),AP(NP),P1,P2,P3,X,A
      REAL(KIND(0.0D0))  XX,DELPH

      IF(NP1.GT.5000) STOP 'NP1 in TRNS'
      IF(NP2.GT.5000) STOP 'NP2 in TRNS'

      CALL gaulegch(-1.0D0,1.0D0,XP1,AP1,NP1)

      DO 1 I=1,NP1
      X=XP1(I)
      A=AP1(I)
      XX=1D0/P1-(1D0/P1-2D0/P2)*X
      XP1(I)=(1D0+X) / XX
      AP1(I)=(2D0/P1-2D0/P2)*A / XX**2
1     CONTINUE
!
      IF(NP2 .NE. 0) THEN

      CALL gaulegch(-1.0D0,1.0D0,XP2,AP2,NP2)

      DO 2 I=1,NP2
      X=XP2(I)
      A=AP2(I)
      DELPH=(P3-P2)/2D0
      XP2(I)=(P3+P2)/2D0 + DELPH*X
      AP2(I)=DELPH*A
2     CONTINUE
      ENDIF
!
      DO 3 I=1,NP1
      XP(I)=XP1(I)
      AP(I)=AP1(I)
3     CONTINUE
!
      IF(NP2 .NE. 0) THEN
      DO 4 I=1,NP2
      XP(I+NP1)=XP2(I)
      AP(I+NP1)=AP2(I)
4     CONTINUE
      ENDIF
!
      RETURN
      END SUBROUTINE
!***************************************************************************************************





!***************************************************************************************************
      SUBROUTINE GAULEGCH(X1,X2,X,W,N)
      IMPLICIT NONE
      INTEGER N,M,I,J
      REAL(KIND(0.0D0)) X1,X2,X(N),W(N),EPS,XM,XL,Z,P1,P2,P3,PP,Z1
      PARAMETER (EPS=3.0D-14)
      M=(N+1)/2
      XM=0.5D0*(X2+X1)
      XL=0.5D0*(X2-X1)
      DO 12 I=1,M

        Z=COS(3.141592653589793238D0*(REAL(I,KIND(0.0D0))-0.25D0)/(REAL(N,KIND(0.0D0))+0.5D0))
1       CONTINUE
          P1=1D0
          P2=0D0
          DO 11 J=1,N
            P3=P2
            P2=P1
            P1=((2.0D0*J-1D0)*Z*P2-(J-1D0)*P3)/J
11        CONTINUE
          PP=N*(Z*P1-P2)/(Z*Z-1D0)
          Z1=Z
          Z=Z1-P1/PP
        IF(ABS(Z-Z1).GT.EPS)GO TO 1
        X(I)=XM-XL*Z
        X(N+1-I)=XM+XL*Z
        W(I)=2.0D0*XL/((1.0D0-Z*Z)*PP*PP)
        W(N+1-I)=W(I)
12    CONTINUE
      END SUBROUTINE GAULEGCH
!***************************************************************************************************






!***************************************************************************************************
SUBROUTINE PARCCH(POT,POTEN,JMOM)
IMPLICIT NONE
INTEGER                    ::K,JMOM
REAL(KIND(0.0D0))          ::SUM(6),POTEN(NZPUN),POT(6)
INTENT(IN)                 ::POTEN,JMOM
INTENT(OUT)                ::POT

SUM=0.0D0
IF (JMOM == 0) THEN
  DO K=1,NZPUN
    SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*PL(K)
    SUM(3)=SUM(3)+POTEN(K)*ZPUN(K)*ZWEI(K)*PL(K)
  END DO
ELSE
  DO K=1,NZPUN
    SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*PL(K)
    SUM(2)=SUM(2)+POTEN(K)*ZWEI(K)*PL(K)
    SUM(3)=SUM(3)+POTEN(K)*ZWEI(K)*PLP(K)
    SUM(4)=SUM(4)+POTEN(K)*ZWEI(K)*PLM(K)
  END DO
END IF
POT=2.0D0*PI*SUM
END SUBROUTINE PARCCH
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE PARSIGCH(POT,POTEN,JMOM)
IMPLICIT NONE
INTEGER                    ::K,JMOM
REAL(KIND(0.0D0))          ::SUM(6),POTEN(NZPUN),POT(6)
INTENT(IN)                 ::POTEN,JMOM
INTENT(OUT)                ::POT

SUM=0.0D0
IF(JMOM == 0) THEN
  DO K=1,NZPUN
    SUM(1)=SUM(1)-3.0D0*POTEN(K)*ZWEI(K)*PL(K)
    SUM(3)=SUM(3)+POTEN(K)*ZPUN(K)*ZWEI(K)*PL(K)
  END DO
ELSE
  DO K=1,NZPUN
    SUM(1)=SUM(1)-3.0D0*POTEN(K)*ZWEI(K)*PL(K)
    SUM(2)=SUM(2)+POTEN(K)*ZWEI(K)*PL(K)
    SUM(3)=SUM(3)+POTEN(K)*ZWEI(K)*PLP(K)
    SUM(4)=SUM(4)+POTEN(K)*ZWEI(K)*PLM(K)
  END DO
END IF
POT=2.0D0*PI*SUM
END SUBROUTINE PARSIGCH
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE PARSIGDCH(POT,POTEN,JMOM,QPUN,QPUNP)
IMPLICIT NONE
INTEGER                    ::K,L,JMOM
REAL(KIND(0.0D0))          ::SUM(6),POTEN(NZPUN),&
                             QPUN,QPUNP,POT(6),LLDUM
INTENT(IN)                 ::POTEN,JMOM,QPUN,QPUNP
INTENT(OUT)                ::POT

L=JMOM
SUM=0.0D0
IF (JMOM == 0) THEN
  DO K=1,NZPUN
      SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*(-QPUN**2-QPUNP**2+2.0D0*QPUN*QPUNP*&
           ZPUN(K))*PL(K)
      SUM(3)=SUM(3)-POTEN(K)*ZWEI(K)*((QPUN**2+QPUNP**2)*ZPUN(K)-2.0D0*QPUN*&
           QPUNP)*PL(K)
  END DO
ELSE
  DO K=1,NZPUN
        SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*(-QPUN**2-QPUNP**2+2.0D0*QPUN*QPUNP*&
           ZPUN(K))*PL(K)
        SUM(2)=SUM(2)+POTEN(K)*ZWEI(K)*((QPUN**2+QPUNP**2)*PL(K)-&
             2.0D0*QPUN*QPUNP/REAL(2*L+1,KIND(0.0D0))*(REAL(L,KIND(0.0D0))*PLP(K)+&
             REAL(L+1,KIND(0.0D0))*PLM(K)))
        SUM(3)=SUM(3)+POTEN(K)*ZWEI(K)/REAL(2*L+1,KIND(0.0D0))*(-(QPUN**2+QPUNP**2)*&
             PLP(K)+2.0D0*QPUN*QPUNP*PL(K))
        SUM(4)=SUM(4)+POTEN(K)*ZWEI(K)/REAL(2*L+1,KIND(0.0D0))*((QPUN**2+QPUNP**2)*&
             PLM(K)-2.0D0*QPUN*QPUNP*PL(K))
        LLDUM=REAL(L*(L+1),KIND(0.0D0))
        SUM(5)=SUM(5)+2.0D0*POTEN(K)*ZWEI(K)*SQRT(LLDUM)/&
             REAL(2*L+1,KIND(0.0D0))*(QPUNP**2*PLP(K)+&
             QPUN**2*PLM(K)-2.0D0*QPUN*QPUNP*PL(K))
        SUM(6)=SUM(6)+2.0D0*POTEN(K)*ZWEI(K)*SQRT(LLDUM)/&
             REAL(2*L+1,KIND(0.0D0))*(QPUNP**2*PLM(K)+&
             QPUN**2*PLP(K)-2.0D0*QPUN*QPUNP*PL(K))
  END DO
END IF
POT=2.0D0*PI*SUM
END SUBROUTINE PARSIGDCH
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE PARSLCH(POT,POTEN,JMOM,QPUN,QPUNP)
IMPLICIT NONE
INTEGER                    ::K,JMOM
REAL(KIND(0.0D0))          ::SUM(6),POTEN(NZPUN),&
                             QPUN,QPUNP,POT(6)
INTENT(IN)                 ::POTEN,JMOM,QPUN,QPUNP
INTENT(OUT)                ::POT

SUM=0.0D0
IF (JMOM == 0) THEN
  DO K=1,NZPUN
     SUM(3)=SUM(3)+POTEN(K)*QPUN*QPUNP*(ZPUN(K)**2-1.0D0)*ZWEI(K)*PL(K)
  END DO
ELSE
  DO K=1,NZPUN
    SUM(2)=SUM(2)+POTEN(K)*QPUNP*QPUN/REAL(2*JMOM+1,KIND(0.0D0))*ZWEI(K)*(PLP(K)-&
         PLM(K))
    SUM(3)=SUM(3)-POTEN(K)*QPUNP*QPUN*ZWEI(K)*(PL(K)-ZPUN(K)*PLP(K))
    SUM(4)=SUM(4)-POTEN(K)*QPUNP*QPUN*ZWEI(K)*(PL(K)-ZPUN(K)*PLM(K))
  END DO
END IF
POT=2.0D0*PI*SUM
END SUBROUTINE PARSLCH
!***************************************************************************************************





!***************************************************************************************************
REAL(KIND(0.0D0))   function plff(x,n)
!======================================
! calculates Legendre polynomials Pn(x)
! using the recurrence relation
! if n > 100 the function retuns 0.0
!======================================
double precision x
integer n, k
double precision pln(0:n)

pln(0) = 1.0

pln(0) = 1.0
if(n>0) then
 pln(1) = x
end if

if (n <= 1) then
  plff = pln(n)
  else
  do k=1,n-1
    pln(k+1) = ((2.0*k+1.0)*x*pln(k) - float(k)*pln(k-1))/(float(k+1))
  end do
  plff = pln(n)
end if
return
end function plff
!***************************************************************************************************





!***************************************************************************************************
integer function GetLECNumPPNP(ostat)
    integer, intent(in) :: ostat
    integer             :: num

    select case(ostat)
        case(0)
            num = size(CLO,1) - 1
        case(1)
            num = size(CNLODR,1) - 1
        case(2)
            num = size(CN2LODR,1) - 1
        case(3)
            num = size(CN3LODR,1) - 1
        case(4)
            num = size(CN4LODR,1) - 1
        case(5)
            num = size(CN4LOPLUSDR,1) + size(CFDR,1) - 1
    end select

    GetLECNumPPNP = num

end function
!***************************************************************************************************





!***************************************************************************************************
subroutine SetLECsPPNP(lecs, n, ostat, cutnumq)
    integer, parameter   :: wp = kind(1.0d0)
    integer, intent(in)  :: n, ostat, cutnumq
    real(wp), intent(in) :: lecs(n)
    integer              :: i

    select case(ostat)
        case(0)
            do i = 1, 2
                CLO(i,cutnumq) = lecs(i)
            end do
            CLO(4,cutnumq) = lecs(3)

        case(1)
             do i = 1, 9
                CNLODR(i,cutnumq) = lecs(i)
            end do
            CNLODR(11,cutnumq) = lecs(10)

        case(2)
            do i = 1, 9
                CN2LODR(i,cutnumq) = lecs(i)
            end do
            CN2LODR(11,cutnumq) = lecs(10)

        case(3)
            do i = 1, 21
                CN3LODR(i,cutnumq) = lecs(i)
            end do
            CN3LODR(23,cutnumq) = lecs(22)

        case(4)
            do i = 1, 21
                CN4LODR(i,cutnumq) = lecs(i)
            end do
            CN4LODR(23,cutnumq) = lecs(22)
            CN4LODR(24,cutnumq) = lecs(23)
        case(5)
            CN4LOPLUSDR(1:21,cutnumq) = lecs(1:21)
            CN4LOPLUSDR(23,cutnumq) = lecs(22)
            CN4LOPLUSDR(24,cutnumq) = lecs(23)
            do i = 1,4
                CFDR(i,cutnumq) = lecs(23+i)
            end do
    end select

end subroutine
!***************************************************************************************************





!***************************************************************************************************
subroutine GetLECsPPNP(lecs, n, ostat, cutnumq)
    integer, parameter    :: wp = kind(1.0d0)
    integer, intent(in)   :: ostat, cutnumq, n
    real(wp), intent(out) :: lecs(n)
    integer               :: i

    select case(ostat)
        case(0)
             do i = 1, 2
                lecs(i) = CLO(i,cutnumq)
            end do
            lecs(3) = CLO(4,cutnumq)

        case(1)
            do i = 1, 9
                lecs(i) = CNLODR(i,cutnumq)
            end do
            lecs(10) = CNLODR(11,cutnumq)

        case(2)
            do i = 1, 9
                lecs(i) = CN2LODR(i,cutnumq)
            end do
            lecs(10) = CN2LODR(11,cutnumq)

        case(3)
            do i = 1, 21
                lecs(i) = CN3LODR(i,cutnumq)
            end do
            lecs(22) = CN3LODR(23,cutnumq)

        case(4)
            do i = 1, 21
                lecs(i) = CN4LODR(i,cutnumq)
            end do
            lecs(22) = CN4LODR(23,cutnumq)
            lecs(23) = CN4LODR(24,cutnumq)
        case(5)
            do i = 1, 21
                lecs(i) = CN4LOPLUSDR(i,cutnumq)
            end do
            lecs(22) = CN4LOPLUSDR(23,cutnumq)
            lecs(23) = CN4LOPLUSDR(24,cutnumq)
            do i = 1, 4
                lecs(23+i) = CFDR(i,cutnumq)
            end do
    end select

end subroutine
!***************************************************************************************************

END MODULE SMSCHIRAL
